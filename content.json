{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"Duk","url":"http://choduk.github.io"},"pages":[],"posts":[{"title":"SpringBoot에 Multi Data Source 적용하기","slug":"jpa/multi-data-source","date":"2017-07-03T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/07/04/jpa/multi-data-source/","link":"","permalink":"http://choduk.github.io/2017/07/04/jpa/multi-data-source/","excerpt":"","text":"DataSource 설정123456789101112// application.yml// DB를 나누기 위해, 메모리 디비를 두개 띄운다app.datasource.blue: url: jdbc:h2:mem:blue username: sa password: app.datasource.green: url: jdbc:h2:mem:green username: sa password: Package Tree DataSourceConfig123456789101112131415161718192021222324252627282930313233343536373839@Configuration@EnableJpaRepositories( basePackages = &#123;BLUE_ENTITY_BASE_PACKAGES&#125;, entityManagerFactoryRef = \"blueEntityManagerFactory\", transactionManagerRef = \"blueTransactionManager\")public class BlueDataBaseConfig &#123; public static final String BLUE_ENTITY_BASE_PACKAGES = \"com.example.demo.blue\"; // 예제엔 Entity와 Repository가 같은 패키지에 있으므로, 위에 패키지 하나로 공유한다 @Bean @Primary @ConfigurationProperties(\"app.datasource.blue\") public DataSourceProperties blueDataSourceProperties() &#123; return new DataSourceProperties(); &#125; @Bean @Primary public DataSource blueDataSource() &#123; return blueDataSourceProperties().initializeDataSourceBuilder().build(); &#125; @Bean @Primary public LocalContainerEntityManagerFactoryBean blueEntityManagerFactory(EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(blueDataSource()) .packages(BLUE_ENTITY_BASE_PACKAGES) .persistenceUnit(\"blue\") .build(); &#125; @Bean @Primary public PlatformTransactionManager blueTransactionManager(@Qualifier(\"blueEntityManagerFactory\") EntityManagerFactory entityManagerFactory) &#123; return new JpaTransactionManager(entityManagerFactory); &#125;&#125; Blue, Green Config가 크게 다르지 않아서 생략.. 하단에 Github을 참고할것(Green에는 @Primary가 빠져있고, 이름만 green으로 시작함) 단일 DataSouce에서 JPA의 EntityManagerFactory, TransactionManager가 존재하므로 이를 나눠줘야 함 TransactionManager가 나뉘어졌으므로, @Transcation을 사용할때 주의할것 SpringBoot 1.3.X 버전부터 EntityManagerFactoryBuilder의 패키지가 변경되었다 (org.springframework.boot.autoconfigure.orm.jpa.EntityManagerFactoryBuilder -&gt; org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder) 주의사항 반드시 1개의 DataSource에 @Primary키워드를 붙여야 한다. 샘플 Github 예제코드 참고자료 Spring.io 공식문서","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Spring","slug":"Develop/Spring","permalink":"http://choduk.github.io/categories/Develop/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://choduk.github.io/tags/Spring-Boot/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://choduk.github.io/tags/Spring-Data-JPA/"}]},{"title":"SOLID - 의존관계 역전 원칙 (DIP)","slug":"solid/dip","date":"2017-06-15T15:00:00.000Z","updated":"2017-10-17T08:17:52.000Z","comments":true,"path":"2017/06/16/solid/dip/","link":"","permalink":"http://choduk.github.io/2017/06/16/solid/dip/","excerpt":"","text":"Dependency inversion principle 상위레벨 모듈이 하위레벨 모듈에 의존하면 안된다. 상위/하위 모듈 모두 추상화에 의존해야 한다. 추상화는 구현체를 의존하면 안된다. 중요한점 OO의 핵심이다. IoC를 통해 상위래밸의 모듈을 하위레벨 모듈로 부터 보호하는 것이다. 이를 통해 OCP를 지키고, 새로운 요구사항을 반영 가능 예제 let) 편의상 Object A =&gt; A, Object B =&gt; B, interface A =&gt; a 라고 하자…{: .center-image} Figure1 그림에서, A -&gt; B 방향으로 Compile time 의존성과 Run time 의존성을 갖고있다. Figure2 그림에서, A,B -&gt; a 방향으로 Compile time 의존성을 맺었지만, Run time 의존성은 그대로이다. 즉, 더이상 A는 B로 의존하지 않으며, A,B 둘다 Compile time에 a에 의존하게 된다. 이때, B의 Compile time의존성 방향이, A의 Run time 의존성 방향과 반대가 되게 된다.이와같이 소스 코드의 의존성 방향이 제어의 흐름과 반대 방향이 될 때, 의존성이 역전됐다고 한다. DIP는 Run time의존이 아닌 Compile time (source code)의존을 역전시킴으로써 변경의 유연함을 확보할 수 있도록 만들어주는 원칙이다. 위 예제에서 Package를 보면, DIP가 적용됨에 따라, interface를 Package A에서 가져가게 되었다. 즉, interface 타입을 가져감으로써 A와 B를 독립적으로 배포(jar, DLL 등)할 수 있도록 만들어 준다. 참고자료 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 클린코더스 강의(15.1강 DIP)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"SOLID - 인터페이스 분리 원칙 (ISP)","slug":"solid/isp","date":"2017-06-04T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/06/05/solid/isp/","link":"","permalink":"http://choduk.github.io/2017/06/05/solid/isp/","excerpt":"","text":"Interface segregation principle 클라이언트는 자신이 사용하는 메서드에만 의존해야 한다. 사용하지 않는 의존성을 갖고 있다면 인터페이스 변경시 재컴파일/빌드/배포가 필요하므로 독립적인 개발/배포 불가능 사용하는 기능만 제공하도록 인터페이스를 분리하여, 사이드이펙트 최소화 클라이언트 입장에서 인터페이스를 분리 흔하디 흔한 스타크래프트 예제12345678910111213141516171819202122232425262728interface Unit &#123; void move(); void attack();&#125;class Marine implements Unit &#123; @Override public void move() &#123; // ... 생략 &#125; @Override public void attack() &#123; // ... 생략 &#125;&#125;class Medic implements Unit &#123; @Override public void move() &#123; // ... 생략 &#125; @Override public void attack() &#123; // 메딕은 공격이 없는데?? &#125;&#125; 개선된 코드1234567891011121314151617181920212223interface Unit &#123;&#125;interface Movable &#123; void move();&#125;interface Attackable &#123; void attack();&#125;class Marine implements Unit, Movable, Attackable &#123; // ... 동일하므로 생략&#125;class Medic implements Unit, Movable &#123; @Override public void move() &#123; // ... 생략 &#125; // attack()에 대해 의존하지 않음&#125; 참고자료 클린코더스 강의(14.3강 ISP)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"SOLID - 리스코프 치환 원칙 (LSP)","slug":"solid/lsp","date":"2017-06-03T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/06/04/solid/lsp/","link":"","permalink":"http://choduk.github.io/2017/06/04/solid/lsp/","excerpt":"","text":"Liskov substitution principle 상위타입 객체를 사용하는 프로그램은 상위타입 대신 하위타입 객체를 사용해도 클라이언트의 수정 없이 정상적으로 동작해야 한다. LSP 위반 사례 명세에 벗어난 값 리턴 명세에 벗어난 익셉션 발생 명세에 벗어난 기능 수행 instanceof / downcasting을 사용한것은 전형적인 LSP 위반 LSP의 대표적인 예(직사각형-정사각형 문제)1234567891011121314151617181920212223242526272829303132333435class Rectangle &#123; private int width; private int height; public void setWidth(int width) &#123; this.width = width; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125;&#125;// 직사각형을 상속받아 정사각형을 만들었을때class Square extends Rectangle &#123; @Override public void setWidth(int width) &#123; super.setWidth(widht); super.setHeight(widht); &#125; @Override public void setHeight(int height) &#123; super.setWidth(height); super.setHeight(height); &#125;&#125; 위 코드의 문제점 LSP를 위반하는 부분 12345void increaseHeight(Rectangle rec) &#123; if(rec.getHeight() &lt;= rec.getWidth()) &#123; rec.setHeight(rec.getWidth() + 10); &#125;&#125; 위와같은 코드를 작성하고 파라미터로 Square를 넘겼을때 width, height가 모두 증가하게 된다. 즉, height만 증가 시킬 수 없다 떄문에, if(rec instance of Square) 와 같은 코드를 넣어서 막아야 한다 이는 상위타입이 하위타입을 대체하지 못해서 코드의 수정이 이뤄졌으므로, LSP를 위반한다. 참고자료 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 클린코더스 강의(14.2강 LSP)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"SOLID - 개방 폐쇄 원칙 (OCP)","slug":"solid/ocp","date":"2017-06-02T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/06/03/solid/ocp/","link":"","permalink":"http://choduk.github.io/2017/06/03/solid/ocp/","excerpt":"","text":"Open-closed principle 확장에는 열려 있고 변경에는 닫혀 있어야 한다. (변화하는 부분을 추상화하여) 기능에 대한 변경/확장이 쉬워야한다. (확장 : 새로운 타입을 추가) 기능을 사용하는 코드는 고정된 추상(abstract, interface)에 의존하므로 소스코드의 수정이 이뤄지면 안된다. OCP를 위배하는 전형적인 특징 다운 캐스팅 123456789// 개발자가 반드시 정복해야 할 객체 지향과 디자인패턴(114page 예제)public void drawCharacter(Character charcater) &#123; if (character instanceof Missile) &#123; Missile missile = (Missile) charcter; missile.drawSpecific(); &#125; else &#123; character.draw(); &#125;&#125; 비슷한 종류의 if-else 블록이 존재 OCP의 현실적인 문제들 (이론적으로 OK, 비실용적) 문제점 main partition에는 if-else 존재 Crystal ball problem (마법의 수정구 문제) 확장을 위해 모든 인터페이스를 준비해놓는 것은 현실적으로 불가능(복잡해짐) 고객은 만져보기위해 자기가 원하는게 뭔지 모른다. 고객은 예측하지 못한 기능추가 변경을 요구 (Unknown Unknowns) 해결책 BDUF (Big Design Up Front) 요구사항을 예측하여 과도한 설계로 인해 발생하는 문제점 대부분 필요치 않은 추상화로 매우 크고 무겁고 복잡해짐 추상화는 유용하고 강력한 만큼 비용도 큼 Agile Design 변화에 대한 가장 좋은 예측은 경험하는 것 예측하고 추상화하기 전에, 고객이 변경을 요구할때 추상화를 한다. 주단위 정도로 간단한 뭔가를 Delivery, 변경을 요구하면 코드를 리팩토링 참고자료 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 클린코더스 강의(14.1강 OCP) 위키백과","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"SOLID - 단일 책임 원칙 (SRP)","slug":"solid/srp","date":"2017-05-28T15:00:00.000Z","updated":"2017-10-18T16:15:49.000Z","comments":true,"path":"2017/05/29/solid/srp/","link":"","permalink":"http://choduk.github.io/2017/05/29/solid/srp/","excerpt":"","text":"Single responsibility principle 클래스는 하나의 책임만 가지며 클래스는 그 책임을 완전히 캡슐화 해야 한다. 여러 책임을 갖고 있는 DataViewer 클래스1234567891011121314151617181920212223// 개발자가 반드시 정복해야 할 객체 지향과 디자인패턴(106page 예제)class DataViewer &#123; public void display() &#123; String data = loadHtml(); updateGui(data); &#125; public String loadHtml() &#123; HttpClient client = new HttpClient(); client.connect(url); return client.getResponse(); &#125; private void updateGui(String data) &#123; GuiData guiModel = parseDataToGuiData(data); tableUI.changeData(guiModel); &#125; private GuiData parseDataToGuiData(String data) &#123; // 파싱 처리 코드 &#125;&#125; 위 코드의 문제점 하나의 책임이 다른 책임까지 영향을 준다 (data를 가져오는 방식이 HTTP방식에서 다른 방식으로 변경된다면, 관련된 모든 코드가 수정되어야 한다.) data를 가져오는 새로운 방식이 추가됐다면, 사용하지 않더라도 불필요한 package를 포함되어야 한다. 개선방안 DataLoader, DataDisplayer 두가지 책임을 분리한다. 둘 간에 주고 받을 데이터를 String이 아닌 추상화된 타입으로 변경한다. 개선된 코드 112345678910111213141516171819202122232425262728293031class Data &#123; ...&#125;class DataLoader &#123; public Data load() &#123; ... &#125;&#125;class DataDisplayer &#123; public void display(Data data) &#123; ... &#125;&#125;class DataViewer &#123; private DataLoader loader = new DataLoader(); private DataDisplayer displayer = new DataDisplayer(); public void display() &#123; Data data = loader.load(); displayer.display(data); &#125; public String loadData() &#123; Data data = loader.load(); return dataToString(data); &#125;&#125; 남아있는 문제점 DataViewer가 DataLoader, DataDisplayer 두 클래스와 Composition을 관계를 형성하므로, 강한 coupling이 존재한다. DataLoader, DataDisplayer 두 클래스가 변경되면, DataViewer 클래스가 영향을 받는다. 개선방안 DataLoader, DataDisplayer를 Aggregation으로 변경한다. 즉, 외부에서 의존성 주입을 한다. (객체간 life cycle 다름) 개선된 코드 2123456789101112131415161718192021222324252627282930313233class Data &#123; ...&#125;interface DataLoader &#123; Data load();&#125;interface DataDisplayer &#123; void display(Data data);&#125;class DataViewer &#123; private final DataLoader loader; private final DataDisplayer displayer; // 외부에서 의존성 주입 public DataViewer(DataLoader loader, DataDisplayer displayer) &#123; this.loader = loader; this.displayer = displayer; &#125; public void display() &#123; Data data = loader.load(); displayer.display(data); &#125; public String loadData() &#123; Data data = loader.load(); return dataToString(data); &#125;&#125; 책임을 나누는 방법 많은 프로그래밍 경험을 바탕으로 감각적으로…(-_-;;) 매서드를 실행하는 주체(Actor)를 확인해 본다 1234567891011121314151617class GUIApplication &#123; ...&#125;class DataProcessor &#123; ...&#125;class DataViewer &#123; public void display() &#123; ... &#125; public String loadData() &#123; ... &#125;&#125; 위와 같은 상황이라면, GUIApplication 클래스는 DataViewer.display() 매서드를, DataProcessor클래스는 DataViewer.loadData() 매서드가 필요하므로, 두 매서드는 각각 다른 책임이므로 분리해야할 가능성이 높다. 참고자료 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 클린코더스 강의(13강 SRP)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"Design Pattern - 행동패턴 (2)","slug":"design-pattern/behavioral-2","date":"2017-05-18T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/05/19/design-pattern/behavioral-2/","link":"","permalink":"http://choduk.github.io/2017/05/19/design-pattern/behavioral-2/","excerpt":"","text":"7.Observer 객체 사이에 1:N 의존관계를 맺고있으며, 한 객체의 상태가 변경되면 의존적인 다른 모든 객체들에게 통지하여 상태를 갱신할 수 있는 패턴 구조{: .center-image} 활용 두개의 추상화 개념이 있고 하나가 다른 하나에 대해 종속적일때, 각각을 별도의 객체로 캡슐화하여 재사용할 수 있음 한 객체에 변경으로 인해 다른 객체를 변경해야하는데, 이때 얼마나 많은 객체들이 변경되어야 할지 모를 때 한 객체가 자신이 변화를 통보하지만 이 변화에대해 관심있는 객체들이 누구인지 몰라도 될 때 결과 Subject와 Observer 간에 추상적인 결합도만 존재함 브로드캐스트(broadcase) 방식의 커뮤니케이션 가능 예측하지 못한 정보를 갱신할 수 있음 잘 알려진 사용 예 스프레드시트와 바 차트 8. State 객체의 내부 상태에 따라 스스로 행위를 변경하도록 하는 패턴 (마치 클래스가 바뀌는 것처럼 보인다) 구조{: .center-image} 활용 런타임에 객체의 행동이 상태에 따라 달라져야할 때 객체의 상태를 나열형 상수(enumerated constant)로 정의해야 할때, 이를 각각의 객체로 정의하여 다른 객체들과 상관없이 그 객체의 상태를 다양화 함 결과 if, switch-case 을 통해 상태별 행위를 처리하지 않고, 서로 다른 상태에 대해 별도의 객체로 표현하여 상태에 따른 행위를 국소화할 수 있음 상태 전이를 명확하게 만듬 (Context객체가 일관되지 않은 상태가 되는것을 막아 줌) 상태객체는 공유될 수 있음 (행동만 있는 Flyweight 처럼 보임) 잘 알려진 사용 예 TCP 프로토콜의 연결 포토샵과 같은 도구에서 선택도구를 이용한 방법 (그림관련 도구 활성화 -&gt; 그림 그려짐, 선택도구 활성화 -&gt; 그림 선택) 9. Strategy 동일 계열의 알고리즘을 정의하고 각 알고리즘을 캡슐화하여 이들을 상호교환 되도록 한다알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 한다 구조{: .center-image} 활용 Strategy패턴은 많은 행동 중 하나를 가진 클래스를 구성할 수 있는 방법을 제공 알고리즘의 변형이 필요할 때 사용자가 몰라야 하는 데이터를 사용하는 알고리즘이 있을 때 노출하지 말아야 할 복잡한 자료구조를 Strategy에 캡슐화 한다 하나의 클래스가 많은 행동을 정의하고, 그 클래스의 연산 안에서 복잡한 다중 조건문의 모습을 취하는 경우 많은 조건문보다는 각각의 Strategy클래스로 바꾸는것이 좋다. 결과 동일 계열의 관련 알고리즘군이 생김 서브클래싱을 사용하지 않는 대안 (context와 무관하게 알고리즘 변경 가능) 조건문을 없앨 수 있음 구현의 선택가능 클라이언트가 서로 다른 전략을 알고 있어야 함 Strategy객체와 Context객체 사이에 메시지 오버헤드가 있음 (모든ConcreteStrategy클래스는Strategy`인터페이스를 공유하기 때문에 사용되지 않는 파라미터를 초기화 경우도 있음) 객체 수 증가 10. Template Method 어떤 작업을 수행하는 알고리즘의 뼈대만 정의하고, 각 스탭별로 수행하는 구체적인 처리는 서브클래스에게 위임 구조{: .center-image} 활용 어떤 알고리즘에 변하는 부분과 변화지 않는 부분을 분리하여, 뼈대만 작성하고(변하지 않는 부분) 구현은(변하는 부분) 서브클래스에게 위임할 때 서브클래스간에 중복된 부분을 추출하여 공통 클래스에 몰아둠으로써 중복을 제거하고자 할때(refactoring to generalize의 좋은 예) 서브클래스 확장을 제어할 수 있음 (특정시점에 hook을 호출하도록 정의하여 그 시점에만 확장 가능하도록 할 수 있음) 결과 Hollywood principle(Don’t call us, we’ll call you)와 같은 역전된 제어 구조가 나타남 Template Method는 아래 operation 중 하나를 호출함 Concrete operation Abstract class Factory method hook operation 잘 알려진 사용 예 거의 모든 추상 클래스에서 사용할 정도로 다양하게 쓰임 11. Visitor 객체 구조를 이루는 원소에 대해 수행할 연산을 표현, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있음 구조{: .center-image} 활용 객체 구조가 다른 인터페이스를 가진 클래스를 포함하고 있어서 구체 클래스에 따라 오퍼레이션을 수행하고자 할때 각각 특징이 있고 관련되지 많은 오퍼레이션들이 어떤 객체에 대해 수행해야 하지만, 오퍼레이션때문에 객체가 복잡하게 되고 싶지 않을 때 객체 구조를 정의한 클래스는 변경되지 않지만, 전체 구조에 걸쳐 새로운 연산을 추가하고 싶을 때 구조를 변경하면 인터페이스 변경이 필요하므로 비용이 더 커질 수 있다. (이경우 해당 연산을 클래스에 정의하는 것이 나음) 결과 새로운 오퍼레이션 추가가 쉬움 Visitor를 통해 관련된 연산을 한 군데로 모아, 관련되지 않은 오퍼레이션을 뗴어낼 수 있음 새로운 ConcreteElement 클래스를 추가하기 어려움 클래스 계층 구조에 걸쳐서 방문함 상태를 누적할 수 있음 캡슐화를 위반할 수 있음 Visitor패턴 적용시 이슈 Double Dispatch : 실행되는 오퍼레이션이 요청의 종류와 수신자의 타입에 따라 달라짐 (방문자는 원소의 각 클래스에 대해 서로 다른 연산을 요청할 수 있음) 누가 객체 순회를 책임지는가? 잘 알려진 사용 예 Smalltalk-80 컴파일러 (소스코드 분석시에 사용)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Design Pattern","slug":"Develop/Design-Pattern","permalink":"http://choduk.github.io/categories/Develop/Design-Pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://choduk.github.io/tags/design-pattern/"},{"name":"behaviroal","slug":"behaviroal","permalink":"http://choduk.github.io/tags/behaviroal/"}]},{"title":"Design Pattern - 행동패턴 (1)","slug":"design-pattern/behavioral-1","date":"2017-05-14T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/05/15/design-pattern/behavioral-1/","link":"","permalink":"http://choduk.github.io/2017/05/15/design-pattern/behavioral-1/","excerpt":"","text":"행동 패턴이란?책임 및 알고리즘을 어떤 객체에 할당하는 것이 좋은지 다룬 패턴 객체간의 교류방법에 대해 정의하여 런타임에 수행하기 어려운 복잡한 제어 구조를 패턴화 한 것 1. Chain of Responsibility 메시지를 보내고 처리하는 객체들 간의 커플링를 없애기 위한 패턴, 각 핸들러는 자신이 처리할 수 있으면 처리하고, 처리할 수 없으면 다음 핸들러에게 요청을 넘긴다. 구조{: .center-image} 활용 하나 이상의 객체가 요청을 처리해야하며 핸들러의 우선순위가 없으며, 각 객체가 자동으로 선택 되어야 할 때 리시버를 명시하지 않은 채 특정 객체에게 요청하고 싶을 때 요청을 처리할 수 있는 객체집합이 동적으로 정의되어야 할 때 결과 객체 간의 결합도(coupling)가 줄어듬 (다른 객체가 요청을 어떻게 처리하는지, 연결구조가 어떻게 된지 몰라도 된다) 책임을 할당하는데 유연성을 높일 수 있음 (책임을 여러 객체에게 분산 시킬 수 있으며, 런타임에 추가/변경/확장 이 가능함) 어떤 객체가 처리할지 명시하지 않으므로, 메시지 처리에 대한 보장이 되질 않음 잘 알려진 사용 예 클래스 라이브러리에서 이벤트 처리 (EventHandler) Logger 2. Command 하나의 요청을 하나의 객체로 캡슐화하여 파라미터처럼 사용할 수 있도록하며 요청을 되돌릴 수 있는 기능을 지원 구조{: .center-image} 활용 수행할 행위를 파라미터로 만들고자 할 때 (절차지향 프로그래밍의 Callback() 과 동일) Command객체는 요청과 다른 생명주기를 가지므로 서로 다른 시간에 요청을 결과 호출객체와 구현객체를 분리 Command는 일급객체 이므로 다른 객체와 같은 방식으로 조작되고 확장할 수 있음 여러 Command를 조합해서 다른 Command를 만들 수 있음 (Composite패턴을 이용하여 여러 명령어 구성 가능) 새로운 Command를 추가하기 쉬움 잘 알려진 사용 예 GUI에서의 메뉴에서 사용자가 MenuItem을 선택하면 Command에 등록된 Execute()연산을 호출함 3. Interpreter 어떤 언어에 대해, 문법에 대한 표현을 정의하면서 표현을 사용하여 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의 구조{: .center-image} 활용 정의할 언어의 문법이 간단함 효율성은 고려사항이 아님 가장 효율저인 interpreter를 구현하는 방법은 파스 트리를 직접 처리하는 것이 아니라, 일차적으로 파스트리를 다른 형태로 번역(translate) 시키는것 예를들어, 정규표현식은 일반적으로 유한상태기계(fninite state machine)으로 변역함 결과 문법을 확장하거나 바꾸기 쉽움 문법의 구현이 쉽움 복잡한 문법은 관리하기 어려움 새로운 표현식의 해석방법을 추가할 수 있음 잘 알려진 사용 예 객체지향 컴파일러 Composite패턴이 사용되는 곳에 Interpreter패턴을 사용할 수 있음, (단 Composite 패턴으로 정의한 클래스들이 하나의 언어 구조를 정의할 때만 Interpreter라고 불림) 4. Iterator 내부구조를 노출하지 않고, 집합 객체(aggregate object)에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공 구조{: .center-image} 활용 객체 내부 표현 방식을 모르고, 집합 객체의 각 원소들에 접근하고 싶을 때 집합 객체를 순회하는 다양한 방법을 지원하고 싶을 때 다른 집합 객체 구조에 대해서도 동일한 인터페이스를 제공하고자 할 때 결과 집합 객체의 다양한 순회방법을 제공 Iterator는 Aggregate클래스의 인터페이스를 단순하게 만듬 집합 객체에 따라 여러 순회 방법을 제공 잘 알려진 사용 예 컬렉션 클래스 5. Mediator 객체들간의 상호작용을 캡슐화하여 하나의 객체에 정의 (참조 관계를 직접 정의하기보다는 독립된 다른객체가 관리) 구조{: .center-image} 활용 여러 객체가 복잡한 상호작용을 가질 때 (객체간 의존성이 구조화 되어 있지 않고, 이해하기 어려울 때) 한 객체가 다른 객체를 너무 많이 참조하고 너무 많은 일을 수행하여 재사용하기 어려울 때 여러 클래스에 분산된 행동들이 상속없이 수정되어야 할 때 결과 서브클래싱 제한함 Colleague객체 사이의 종속성 줄임 객체 프로토콜을 단순하게 만듬 객체 간의 협력 방법을 추상화함 통제의 집중화 (Mediator 클래스 자체의 유지보수가 어려워질 수 있음) 잘 알려진 사용 예 Windows 플랫폼용 스몰토크/V의 응용프로그램에서 pane 클래스 계통의 객체들이 많이 제공되는데 (TextPane, ListBox, Button 등), 이들은 별다른 상속없이도 ViewManager 클래스만 상속받으면 된다. {: .center-image}{: .center-image} 스몰토크/V 에서의 Mediator 6. Memento 캡슐화를 위배하지 않을 채 어객체의 내부 상태를 캡처해두고, 이후 그 상태로 되돌아올 수 있도록 함 구조{: .center-image} 활용 객체 상태에 대한 스냅샷을 저장한 후 상태를 되돌릴 때 상태를 얻기위한 인터페이스를 두면 객체의 세부 구현이 드러나서 캡슐화가 위배될 때 결과 캡슐화된 경계를 유지할 수 있음 Originator 클래스가 단순해짐 Memento의 사용으로 더 많은 비용이 발생할 수 있음 제한적 / 광범위한 인터페이스를 정의해야함 (어떤 언어에서는 Originator 객체에서만 Memento의 상태 접근을 보장하기 어려울 수 있음) Caretaker는 자신이 보관한 Memento를 삭제할 책임이 있음으로, Memento를 관리하는데 추가적인 비용이 들어갈 수 있음","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Design Pattern","slug":"Develop/Design-Pattern","permalink":"http://choduk.github.io/categories/Develop/Design-Pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://choduk.github.io/tags/design-pattern/"},{"name":"behaviroal","slug":"behaviroal","permalink":"http://choduk.github.io/tags/behaviroal/"}]},{"title":"Design Pattern - 구조패턴","slug":"design-pattern/structural","date":"2017-05-13T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/05/14/design-pattern/structural/","link":"","permalink":"http://choduk.github.io/2017/05/14/design-pattern/structural/","excerpt":"","text":"구조 패턴이란?더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는지에 관련된 패턴 인터페이스나 구현을 복합하는 것이 아니라 새로운 기능을 실현하기 위해 객체를 합성하는 방법을 제공하여 런타임에 복합 방법이나 대상을 변경할 수 있음 1. Adapter 클래스의 인터페이스를 원하는 형태로 변환하여, 서로 다른 인터페이스를 갖는 클래스들을 함께 동작하게 하도록 함 구조{: .center-image} 활용 기존 클래스를 사용하고자 하는데 인터페이스가 맞지 않을 때 인터페이스가 맞지 않는 수정이 불가능한 라이브러리를 재사용하려 할 때 (객체 적응자(object adapter)만 해당) 수정해야할 인터페이스가 현실적으로 불가능할 정도로 많을 때 객체 적응자를 써서 부모 클래스의 인터페이스를 변형 결과 클래스 적응자(class Adapter) Adapter는 명시적으로 Adaptee를 상속받고 있을뿐 Adaptee의 서브클래스들을 상속받는 것이 아니므로 서브클래스들에 정의된 기능을 사용할 수 없음 객체 적응자(object Adapter) Adapter는 하나만 존재해도 여러 Adaptee와 동작 가능 Adpatee는 행위 재정의가 어려움 잘 알려진 사용 예 그래픽 객체에서 Graphic과 Line, Circle, Polygon, Spline 2. Bridge 추상과 구현을 분리하여, 독립적인 다양성을 가질 수 있도록 함 구조{: .center-image} 활용 추상과 구현 사이의 종속성을 제거하여 런타임에 구현 방법을 선택하거나 변경하고 싶을 때 추상과 구현 모두 독립적으로 확장이 필요 할 때 구현 내용을 변경한다고해서 추상이 다시 컴파일 될 필요 없어야 한다 클라이언트로부터 구현을 은닉하고 싶을 때 여러 객체들에 걸쳐 구현을 공유하며 이를 다른곳에 공개하지 않고 싶을 때 결과 인터페이스와 구현의 분리 (컴파일 타임 의존성 제거) 확장성 제고 (abstraction과 implementor를 독립적 확장) 구현 세부 사항 은닉 잘 알려진 사용 예 Set은 집합에 대한 추상을 정의, LinkedSet과 HashSSet은 개념적 연결 리스트나 해시테이블에 대한 구현을 제공 3. Composite 부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성하여 개별 객체와 복합객체를 모두 동일하게 다룰 수 있도록 함 구조{: .center-image} 활용 부분, 전체의 객체 계통을 표현하고 싶을 때 객체의 합성으로 생긴 복합객체와 단일객체의 사용을 동일하게 하고 싶을 때 결과 단일객체와 복합객체로 구성된 하나의 계통으로 정의하여 일관된 방식으로 애플리케이션 구성 가능 일관된 방식으로 구성가능하기 때문에 코드가 단순해짐 새로운 구성요소를 쉽게 추가 가능 지나치게 범용성을 갖게 되므로 구성요소에 대한 제약사항을 가하기 어려움 잘 알려진 사용 예 Smaltalk에서 MVC의 View가 Composite 이면서 뷰집합을 포함, 즉 Component이다 금융 분야에서 포트폴리오(portfolio)가 자산(asset)을 형성할 때, 포트폴리오는 각각 자신의 인터페이스를 만족하 전체를 하나의 집합으로 관리할 수 있는 Composite로 구현 4. Decorator 동적으로 새로운 책임을 추가하여, 서브클래스를 만드는것 보다 유연한 확장성 제공 구조{: .center-image} 활용 다른 객체에 영향을 주지 않고 새로운 책임을 추가 가능 책임이 제거될 수 있을때 사용 모든 조합을 지원하기위해 상속해야할 클래스가 지나치게 많을 때 결과 상속보다 유연한 설계로 확장성 제공 많은 기능이 상위 클래스에 누적되는 상황을 피할 수 있음 Decorator와 해당 ConcreteComponent가 동일하지 않음. Decorator는 일관된 인터페이스를 제공하는 껍데기 객체의 행동 뿐만 아니라 내부도 변경 가능 (대표적인예 : Strategy Pattern) 잘 알려진 사용 예 GUI 툴킷에서 위젯의 기능을 추가하고자 할 때 Stream Class (기본적인 I/O) 5. Facade 한 서브시스템을 합성한 여러 인터페이스의 집합에 대해 단순한 하나의 인터페이스를 제공 구조{: .center-image} 활용 복잡한 서브시스템에 단순한 인터페이스를 제공할 때 클라이언트와 서브시스템 간에 너무 많은 종속성이 존재할때, Facade를 통해 결합도를 줄이고 싶을 때 서브 시스템을 계층화하여 결과 서브시스템의 구성요소 보호 클라이언트와 서브시스템 간의 결합도 약화 Facade는 서브시스템을 완전히 막지 않기 때문에, 클라이언트가 Facade와 서브시스템을 선택할 수 있음 잘 알려진 사용 예 choices OS에서 다양한 H/W 플랫폼을 지원하기위해 FileSystemInterface와 주소 공간에 해당하는 Domain을 Facade로 정의 6. Flyweight 데이터를 서로 공유하여 사용하도록 하여 메모리 사용량을 최소화 구조{: .center-image} 활용 애플리케이션이 대량의 객체를 사용할 때 객체의 수가 너무 많아져서 저장 비용이 너무 높을 때 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때 부가적인 속성을 제외하면 비교적 적은 수의 공유된 객체로 대체될 수 있을 때 애플리케이션이 객체에 식별자의 의존하지 않을 때 결과 공유해야하는 인스턴스의 전체 수를 줄일 수 있음 객체별 상태의 양을 줄일 수 있음 부가적인 상태는 연산되거나 저장할 수 있음 잘 알려진 사용 예 Doc문서 편집기에서 하나의 glyph인스턴스를 만들어 특정 스타일의 문자로 공유할 수 있음 (본질적 상태는 글자의 코드와 스타일정보 부가적인 정보는 글자의 위치) 그 결과 18만 글자를 저장하기 위해 단지 480개의 문자 객체만 저장하면 되었음 ET++에서 룩앤필 독립성 보장 스크롤바, 버튼 메뉴 등 위젯이라고 알려진 사용자 인터페이스 요소(layout)와, 음영 각도 등의 장식으로 분리 7. Proxy 객체에 대한 접근을 제어하기 위해서 그 객체를 담을 수 있는 그릇을 제공하는 것입니다 구조{: .center-image} 활용 remote proxy : 서로 다른 주소 공간에 존재하는 객체를 가르키는 객체 virtual proxy : 요청이 있을 때만 필요한 고비용 객체를 생성 protection proxy : 원래 객체에 대한 실제 접근을 제어 smart reference : 실제 객체에 접근이 일어날 때 추가적인 행동을 수행 실제 객체에 대한 참조 횟수를 저장하다가 더는 참조가 없을 때 객체를 제거 (smart pointer 라고 불림) 맨 처음 참조되는 시점에 영속성 저장소의 객체를 메모리로 옮김 실제 객체에 접근하기 전에, 다른 객체가 그것을 변경하지 못하도록 실제 객체에 대한 잠금 결과프록시 패턴은 어떤 객체에 접근할 때 추가적인 작업을 할 수 있는 통로를 제공 remote proxy는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있음 virtual proxy는 요구에 따라 객체를 생성하는 등의 처리를 최적화 할 수 있음 protection proxy / smart reference는 객체가 접근할 때 마다 생성 및 삭제 등의 추가 관리를 책임짐","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Design Pattern","slug":"Develop/Design-Pattern","permalink":"http://choduk.github.io/categories/Develop/Design-Pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://choduk.github.io/tags/design-pattern/"},{"name":"structural","slug":"structural","permalink":"http://choduk.github.io/tags/structural/"}]},{"title":"Design Pattern - 생성패턴","slug":"design-pattern/creational","date":"2017-05-08T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/05/09/design-pattern/creational/","link":"","permalink":"http://choduk.github.io/2017/05/09/design-pattern/creational/","excerpt":"","text":"생성 패턴이란?인스턴스의 생성/합성 방법을 추상화하여 시스템이 어떤 서브클래스를 사용하지에 대한 정보를 캡슐화 누가, 언제, 무엇을, 어떻게 생성할 것인지 결정하는 데 유연성을 확보할 수 있다 1. Factory Method 객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 인스턴스를 생성할지에 대한 결정은 서브클래스에게 위임 구조 활용 생성할 객체 타입을 예측할 수 없을 때 생성할 객체를 기술해야하는 책임을 서브클래스에게 위임하고자 할 때 객체 생성의 책임을 서브클래스(ConcreteProduct)에 위임하고, 서브클래스에 대한 정보를 은닉할 필요가 있을 때 결과 컴파일 타임에는 인터페이스/추상클래스에(Product) 의존성을 맺지만, 런타임에는 서브클래스에(ConcreteProduct) 의존성을 갖게되므로 느슨한 결합(loose coupling)을 할 수 있음 느슨한 결합을 통해, 새로운 서브클래스(ConcreteProduct)를 쉽게 추가할 수 있음 서브클래스(ConcreteProduct)에 대한 hook 메소드 제공 (객체 생성 전후로 어떤 행위를 추가하기 쉬움) 병렬적인 클래스 계통을 연결하는 역할을 담당 (자신의 책임을 다른 클래스에 위임하는것) 2. Abstract Factory 독립적인 여러 제품군(AbstractProduct)을 생성할 수 있는 인터페이스(AbstractFactory)를 제공 구조 활용 서브 클래스의 생성/구성/표현 방식에 의존하지 않는 프로그램 작성할때 특정 Product 하나를 애플리케이션 설정과 함께 다른 Product으로 대체할 때 어떤 Product의 제약사항을 외부에서도 따르게 하고자 할때 Product에 대한 클래스 라이브러리를 제공하고, 구현이 아닌 인터페이스만 노출하고자 할 때 결과 Product의 생성/구성/표현 방식에 대한 전반적인 과정을 캡슐화하여 서브 클래스에 위임했기 때문에, 구체적인 클래스를 분리되어 있음 애플리케이션내에 팩토리의 서브클래스(ConcreteFactory)를 변경하기 쉬기 때문에, 제품군(AbstracProduct)을 쉽게 대체 가능 오직 팩토리의 서브클래스(ConcreteFactory)에서만 객체를 생성함으로, 애플리케이션내에 Product 객체들의 일관성을 높일 수 있음 새로운 Product를 제공하기 어려움 (AbstractFactory가 영향받으면 하위 모든 서브클래스가 영향을 받게됨) 3. Prototype 인스턴스를 복사해서 새로운 인스턴스를 만드는 것 구조 활용 인스턴스화 할 클래스를 런타임에 지정하고 싶을 때 팩토리에서와 같이 Product와 Factory를 병렬적으로 만들고 싶지 않을 때 클래스의 인스턴스가 구성/표현 방식이 복잡할 때 프레임워크와 인스턴스를 분리하고 싶을 때 Composite, Decorator 패턴이 많이 사용될 때 결과 런타임에 새로운 Product를 추가/삭제 할 수 있음 새로운 클래스의 생성 없이 객체에 정의된 필드에 따라 행위를 변경 가능 구조를 다양화 하여 새로운 객체 정의 가능 서브클래스의 수를 줄일 수 있음 동적으로 클래스에 따라 애플리케이션 구성 가능 4. Singleton 오직 한개의 클래스 인스턴스만 갖도록 보장하고, 전역적인 접근을 제공 구조 활용 클래스의 인스턴스가 오직 하나이면서, 전역적인 접근이 필요 할 때 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정 없이 확장된 서브클래스의 인스턴스를 사용할 수 있어야 할 때 결과 유일하게 존재하는 인스턴스로 전역적 접근 통제 namespace의 제한 연산 및 표현의 정제 허용 인스턴스의 개수를 변경하기가 자유로움 클래스 연산을 사용하는 것보다 훨씬 유연 클래스로더가 여러개 있다면, 클래스 로더를 직접 지정해서 사용할 것(여러개의 인스턴스 생성 가능) 고전적인 방식의 lazy instantiation 생성시 멀티스레드 상황에서 문제가 생길 수 있으니 주의할것 해결법은 다음과 같다. 속도의 문제가 없다면 synchronized 사용 DCL(Double-checking locking)을 사용하여 getInstance()의 동기화 부분을 줄임 12345678910private Singleton instance;public static Singleton getInstance()&#123; if (instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null) instance = new Singleton(); &#125; return instance; &#125; 인스턴스를 처음부터 생성 (권장사항) 1private static Singleton instance = new Singleton(); 특별한 문제가 없다면 Singleton으로 만들어진 객체는 반드시 추가적인 인스턴스 생성을 못하게 막아야 함 5. Builder 복잡한 객체를 생성 및 표현방법을 분리하여, 서로 다른 표현이라도 객체를 생성할 수 있는 동일한 방식을 제공 구조 활용 복합객체 생성 방법이, 각 요소들의 조합 방법에 독립적일 때 합성할 객체들의 표현방법이 다르더라도, 생성과정에서 이를 지원해야 할 때 결과 객체 내부 표현을 다양하게 변화 가능 생성과 표현의 코드를 분리 복합 객체 생성 절차를 세밀하게 분류 가능","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Design Pattern","slug":"Develop/Design-Pattern","permalink":"http://choduk.github.io/categories/Develop/Design-Pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://choduk.github.io/tags/design-pattern/"},{"name":"creational","slug":"creational","permalink":"http://choduk.github.io/tags/creational/"}]}]}