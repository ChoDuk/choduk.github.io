{"meta":{"title":"Duk Dev Note","subtitle":null,"description":null,"author":"Duk","url":"http://choduk.github.io"},"pages":[{"title":"ABOUT","date":"2017-07-25T10:30:25.000Z","updated":"2018-01-01T04:08:13.811Z","comments":true,"path":"about/index.html","permalink":"http://choduk.github.io/about/index.html","excerpt":"","text":"Hello world!"}],"posts":[{"title":"Java Garbage Collection (1)","slug":"java/garbage-collection-1","date":"2018-01-06T15:00:00.000Z","updated":"2018-01-08T17:35:37.101Z","comments":true,"path":"2018/01/07/java/garbage-collection-1/","link":"","permalink":"http://choduk.github.io/2018/01/07/java/garbage-collection-1/","excerpt":"","text":"GC가 하는일 Heap 내에서 사용되지 않는 Object를 찾는다 해당 메모리를 회수한다 들어가기 전에… 용어정리 STW(Stop The World) : JVM이 GC를 실행하는 Thread를 제외한 나머지 모든 Thread를 멈추는것 Reachable : 어떤 객체 유효한 참조가 있을때 Unreachable : 어떤 객체에 유효한 참조가 없을때 Root set : 객체의 참조여부를 파악하기 위한 최초의 유효한 참조 GC 기본 프로세스 Step1. Marking GC가 Unreachable Object를 찾아낸다 이때 모든 객체를 스캔하므로 시간이 오래걸린다 Step2. Normal Deletion Unreachable Object를 삭제한다 제거된 객체의 포인터를 남겨두었다가, 추후 새로운 객체가 할당되면 해당 위치에 추가한다 Step3. Compacting 성능을 위해 Reachable Object를 묶는다 Compacting을 과정을 수행함으로써, 삭제된 객체들 사이에 발생한 Fragmentation 문제와 재할당이 쉬워진다(마지막에만 객체를 추가하면됨) 비효율적인 프로세스위에 명시한 GC의 기본 프로세스는 모든 객체를 스캔해야 하므로 비효율적이다. 위 표를 보면, 일반적인 애플리케이션에서 대부분의 객체의 LifeTime이 짧다. 때문에 Heap을 더 작은 파트(Young, Old, Permanent)로 나누어 퍼포먼스를 향상시킬 수 있다. Weak generational hypothesis 대부분의 객체는 금방 접근 불가능 상태가 된다(unreachable) 오래된 객체에서젊은 객체로의 참조는 아주 적게 존재한다 Oracle HotSpot Heap Structure Young 영역 (Young Generation) Old 영역 (Old Generation) Permanent 영역 (Permanent Generation) HotSpot VM에서 더 빠른 메모리 할당을 위해 사용하는 방법 TLAB (Thread Local Allocation Buffers) 각 Thread에 Eden영역에 작은 부분을 미리 할당 각 Thread들은 자신이 갖고있는 TLAB에만 접근할 수 있다. 활성화 옵션 -&gt; -XX:+UseTLAB Bump the Pointer Allocation Eden영역에 할당된 마지막 객체의 위치를 추적 (Eden의 맨위에 존재) 새로 할당할 객체가 Eden영역에 넣을 수 있는 크기인지 판단 Multi Thread 환경에서 Thread들이 Eden영역에 저장하려면 Lock이 발생해야하지만, TLAB을 통해 각자의 영역에 저장하므로, Lock없이 가능하다. Young 영역객체가 가장 먼저 생성되는 영역으로, Eden영역과 2개의 Survivor영역으로 구성되어있다. 해당 영역에서 이뤄지는 GC를 Minor GC라고 한다 Young 영역의 처리 순서 새로 생성되는 대부분의 객체는 대부분 Eden에 생성 Eden에서 GC가 발생 -&gt; 살아남은 객체는 Survivor 영역중 한곳으로 이동 동일한 Survivor 영역이 꽉 찰때까지 2번 반복 Survivor에서 GC 발생 -&gt; 살아남은 객체는 다른 Survivor영역으로 이동, 이때 두개의 Survivor영역중 한곳은 반드시 비어있어야 한다 1~4 과정을 반복하다가, 지속적으로 살아남은 객체는 Old 영역으로 이동 (promotion) Old 영역위 Young 영역에서 지속적인 GC에도 살아남은 객체들이 모이는 영역으로, 이곳에서 이뤄지는 GC를 Full GC라고 한다. Full GC는 Minor GC에 비해 STW시간이 훨씬 길기 때문에, 성능에 큰 영향을 끼친다. Old 영역 GC 종류 Serial GC Parallel GC / Parallel Old GC CMS GC (Concurrent Mark &amp; Sweep GC) G1 GC (Garbage First GC) Permanent 영역Heap 메모리 영역중 하나로, 애플리케이션이 실행될때 클래스의 메타데이터를 저장하는 영역 Class의 Meta 정보(이름, 패키지 주소 등) Method의 Meta 정보 상수 string / static object 등 JVM 내부 객체 / 컴파일러 최적화 정보(JIT) 등등.. 무분별한 Static Object의 사용과, HotDeploy로 인한 Meta Data 증가로 PermGen Space OOM를 방지하고자, 해당 영역을 java8 부터 삭제하였다. Class / Method의 메타데이터 / JVM 내부 객체 및 컴파일러 최적화 정보 -&gt; MetaSpace로 이동 상수 string / static object -&gt; Heap으로 이동 참고문헌 NAVER helloworld blog NAVER helloworld blog Oracle java garbage collection basics 삵 blog","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"JAVA","slug":"Develop/JAVA","permalink":"http://choduk.github.io/categories/Develop/JAVA/"}],"tags":[{"name":"GC","slug":"GC","permalink":"http://choduk.github.io/tags/GC/"}]},{"title":"Java Garbage Collection (2)","slug":"java/garbage-collection-2","date":"2018-01-06T15:00:00.000Z","updated":"2018-01-08T17:37:21.851Z","comments":true,"path":"2018/01/07/java/garbage-collection-2/","link":"","permalink":"http://choduk.github.io/2018/01/07/java/garbage-collection-2/","excerpt":"","text":"Old GC Serial GC Parallel GC Parallel Old GC CMS GC (Concurrent Mark &amp; Sweep GC) G1 GC (Garbage First GC) Serial GC Young 영역에서는 기본적인 GC 동작방식을 그대로 따름 Old 영역에 대해서 mark-sweep-compact 알고리즘을 이용 해당 GC는 메모리가 적고 적은수의 CPU에서만 사용하기 적합 활성화 옵션 -&gt; -XX:+UseSerialGC Serial Collector의 한계애플리케이션이 거대해짐에 따라 Heap 메모리가 함께커지므로 Serial Collector 성능의 한계가 나타나게 됨 (Full GC로 인한 suspend) Throughput Collector -&gt; 병렬처리를 통해 통해 성능 개선 Low Pause Collector -&gt; suspend를 분산시켜 STW 시간을 줄이는 방법 Parallel GC Throughput Collector 라고도 불림 JDK 4에 추가됨 Serial GC와 동작방식이 같으나, Multi-Thread가 동시에 Garbage Collection을 수행 (Parallel Copy Algorithm) Young 영역에서만 동작함 (Minor GC) 활성화 옵션 -&gt; -XX:+UseParallelGC Parallel Old GC Parallel Compaction Collector 라고도 불림 JDK 5 Update6 에 추가됐으며, JDK 6부터 디폴트 방식이 됨 Parallel Collector에 Old 영역 GC(Major GC) 방식이 변경(Mark-Sweep-Compaction -&gt; Mark-Summary-Compaction) Mark Old 영역을 Region 단위로 균일하게 나눔 (Region 은 논리적인 구역이다, 보통 2kbytes 단위) STW가 발생하며 Parallel하게 각 Thread가 Live Object를 Marking Live Object의 size 및 위치 정보 등을 갱신함 Summary 각 Region Live Object 밀도를 평가하여, Dense prefix를 설정 Dense prefix를 기준으로 왼쪽은 GC대상에서 제외되고, 오른쪽은 GC / Compaction 대상 즉, Dense prefix란, 위에서 측정한 밀도정보를 바탕으로 어느 Region을 GC / Compaction 대상으로 삼을지 정하는 작업을 뜻함 Compaction STW발생 Summary에서 GC 대상이된 Region을 담당하는 Thread 들이 수행 Source Region 을 제외한 나머지 Region에서 Sweep를 수행하여, GC를 수행 (Source Region이란, Compaction 대상이 되는 주로 우측에 있는 Region들) Destination Region들이 Sweep 된 이후, Source Region에서 Live Object 들을 Destination Region에 옮김 활성화 옵션 -&gt; -XX:+UseParallelOldGC CMS GC (Concurrent Mark &amp; Sweep GC) Low Pause Collector 의 일종으로, suspend time을 분산하여 응답시간을 개선한 방식으로, Low Latency GC 라고도 불림 Young 영역에서는 Parallel GC와 동일 (Parallel Copy Algorithm) Old 영역에서는 Concurrent Mark-Sweep Algorithm (Initial Mark, Concurrent Mark, Remark, Concurrent Sweep) Initial Mark STW가 발생하며, Single Thread에서 수행 Root set에서 Live Object 만 빠르게 Mark 전체 Object를 탐색하는 것이 아니기 때문에 굉장히 짧음 Concurrent Mark Initial Mark에서 발견된 Live Object 들이 참조하는 다른 Object들을 찾아서 Mark STW가 발생하지 않고, Concurrent하게 수행됨 때문에 해당 작업 도중 새로운 객체가 생성될 수 있음 Remark STW가 발생하며, Multi-Thread에서 수행 Concurrent Mark 과정중 생성된 객체 및 찾아낸 모든 Live Object들이 아직 Reachability한지 탐색 Concurrent Sweep 각 Thread에서 Sweep를 수행 주의할점 Compacting 단계가 없기 때문에, Memory Fragmentation가 발생 할 수 있음 Memory Fragmentation 보완방법 Heap을 Size를 크게 잡는다 -&gt; Major GC의 시간이 늘어나게됨 Free List를 사용 : promotion된 object의 크기와 비슷한 free space를 탐색하여 배치하는 방법이지만, 적절한 배치를 위한 Overhead가 발생 활성화 옵션 -&gt; -XX:+UseConcMarkSweepGC Minor GC디폴트값 -&gt; -XX:+UseParNewGC G1 GC (Garbage First GC) JDK 7 update4 부터 지원 전체 Heap을 동일한 크기의 연속된 공간으로 나눔, 나뉘어진 각 영역들을 region이라고 함 region들은 각각 Eden, Survivor, Old공간으로 논리적으로 매핑됨 (논리적 맵핑으로 쉽게 리사이징 가능) 그 이외의 region Humongous region : 객체가 region 크기에 50% 이상 차지할때, 인접 region에 함께 저장 unused areas : Heap에서 아직 사용되지 않은 영역 Minor GC STW가 발생 Young 영역에서 Live Object 찾아서 적절한 region에 복사한다. (Oracle 문서엔 대피시킨다고 표현함) Multi Thread 로 실행됨 Major GC (Concurrent Marking Cycle) Concurrent Marking Multi Thread로 동작하며, 애플리케이션과 Concurrnet하게 수행 Old영역에서 Live Object를 마킹함 Evacuation pause와 동시에 실행 가능하다 (=Minor GC를 뜻함) Remark (STW) SATB 알고리즘 사용 (CMS보다 훨씬 빠르다고함) 완전히 비어있는 region이 반환됨 Copying/Cleanup (STW) Multi Thread로 동작 region에 liveness 정보를 갱신 이것만 봐서는 g1이 내부적으로 어떻게 동작하는지 도저히 와닿지가 않아, 검색을 해보니 설명이 굉장히 잘 나온 블로그가 있어서 별도로 기재한다.이곳에서 G1 GC의 수행단계를 확인하고,이곳에선 G1 GC internal 자료구조와 동작방식을 확인하면 좋을것 같다. 참고문헌 Introduction of Java GC Tuning and Java Java Mission Control NAVER helloworld blog Oracle Getting Stared with the G1 Garbage Collector initproc blog appchemist blog","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"JAVA","slug":"Develop/JAVA","permalink":"http://choduk.github.io/categories/Develop/JAVA/"}],"tags":[{"name":"GC","slug":"GC","permalink":"http://choduk.github.io/tags/GC/"}]},{"title":"React boilerplate 만들기","slug":"react/react-env","date":"2017-12-31T15:00:00.000Z","updated":"2018-01-01T16:38:50.284Z","comments":true,"path":"2018/01/01/react/react-env/","link":"","permalink":"http://choduk.github.io/2018/01/01/react/react-env/","excerpt":"","text":"React + babel + webpack 으로 boilerplate 생성 정리 프론트 알 못이라… 이번 기회에 각 용어와 셋팅 방법을 정리해보려고 한다 목차 들어가기 전에.. 프로젝트 생성 webpack 설치 bebel 설치 webpack 설정 react webpack plugin 추가 들어가기 전에.. webpack 이란? js 파일을 하나로 번들링 해준다 (웹페이지 요청시 request 숫자를 줄일 수 있다) npm 패키지를 Front-end에서 사용할 수 있다 ES6, ES7 등 더 많은 기능을 쓸 수 있다 불필요한 파일을 빼고 번들링이 가능하다 less, scss 등을 사용할 수 있다 (css로 변경 가능) Hot Module Replacement 를 사용할 수 있다 어떤 파일이던 js파일에 넣어준다 babel 이란? ES6, ES7으로 작성된 코드들을 ES5코드로 transpiling 해주는것 다양한 모듈을 담는 역할을 하며, 코드를 transpiling 하기위해 작은 모듈(presets)을 사용한다 babel-cli : transpiling 수행 babel-register : 각 모듈을 결합할 때 사용 (production 용이 아니다) .babelrc : 바벨 설정 파일(설정하지 않으면 단순히 파일을 옮기는 작업만 수행) babel-polyfill : ES6 환경 제공 babel-plugins : babel에 여러 transform-plugin을 추가, .babelrc에서 설정하여도 되고 webpack에서 설정해도 된다 transpiling 이란? 한 언어로 작성된 소스코드를 비슷한 수준의 추상화를 가진 다른언어로 변환하는 방법 (ex: typescript -&gt; javascript) 즉 ES6/ES7으로 작성한 js파일을 babel을 통해 transpiling 되고, webpack이 이를 하나의 js파일로 번들링 해준다 npm 이란? Node Package Modules 의 약자 node.js의 패키지 관리툴로서 자바스크립트로 패키지된 모듈들을 쉽게 공유할 수 있도록 도와주는 오픈소스 프로젝트 개발자가 어떤 패키지를 쉽게 설치하고 퍼블리싱 할 수 있는 command line client 프로젝트 생성(npm은 pc에 설치되어있다고 가정하고 진행)비어있는 boilerplate 폴더 생성후 npm을 init한다12$ mkdir react-boilerplate &amp;&amp; cd react-boilerplate$ npm init -y webpack 설치위에서 생성한 폴더에 npm을 이용해 webpack을 설치하고 webpack 설정 파일(webpack.config.js)을 생성한다12$ npm i webpack --save-dev$ touch webpack.config.js babel 설치마찬가지로 npm을 이용해 babel과 관련된 코어모듈을 함께 설치하고 babel 설정파일(.babelrc)을 생성한다12$ npm i babel-loader babel-core babel-preset-env babel-preset-react --save-dev$ touch .babelrc 주의! babel-preset-es2015는 deprecated 되었으므로 babel-preset-env를 쓰자 위에 만든 .babelrc파일에 다음과 같이 설정한다123&#123; &quot;presets&quot;: [&quot;env&quot;, &quot;react&quot;]&#125; webpack 설정아까 위에서 만든 webpack.config.js파일을 열어서 다음과 같이 설정한다12345678910111213141516171819// webpack.config.jsconst path = require('path');module.exports = &#123; entry: ['./src/app/App.js'], output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.js$/, loader: 'babel-loader', exclude: ['/node_modules/'] &#125; ] &#125;&#125;; 위 webpack.config.js설정에서 entry point를 ./src/app.js에 만들었으므로, 해당 파일을 하나 만들자 1$ mkdir -p src/app &amp;&amp; touch ./src/app/App.js 여기까지 만든 이후, webpack이 정상 작동을 하는지 테스트 한번 해보자package.json파일을 열어서 다음과 같이 추가한다 12345678// package.json&#123; // ...생략 \"scripts\": &#123; \"build\": \"webpack\" &#125; // ...생략&#125; 이후 아래를 명령어를 입력했을때 webpack설정에 적혀있듯이, dist폴더 하단에 bundle.js로 정상적으로 만들어 지는지 확인하자1$ npm run build React위와 마찬가지로 npm을 이용하여 react와 react-dom을 설치한다 1$ npm i react react-dom --save-dev 이제 react를 구성하기 위한 간단한 Hello App을 만든다 1$ mkdir public &amp;&amp; touch public/index.html 1234567891011&lt;!- public/index.html -&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;React App&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"container\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819// src/app/App.jsimport React, &#123; Component &#125; from \"react\";import ReactDOM from \"react-dom\";class App extends Component &#123; constructor() &#123; super(); this.state = &#123; title: \"Hello App\" &#125;; &#125; render() &#123; return ( &lt;h3&gt;&#123;this.state.title&#125;&lt;/h3&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById('container')); webpack plugin 추가HTML webpack pluginpublic/index.html에 자동으로 &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 태그를 넣어 줄 수 있도록 plugin을 추가한다 1$ npm i html-webpack-plugin html-loader --save-dev webpack.config.js 파일 하단에 플러그인을 넣어준다1234567891011121314// webpack.config.jsconst path = require('path');const HtmlWebPackPlugin = require('html-webpack-plugin');module.exports = &#123; // .. 생략 , plugins: [ new HtmlWebPackPlugin(&#123; template: \"./public/index.html\", filename: \"./index.html\" &#125;) ]&#125; 이후 npm run build 명령어를 실행하여, dist폴더 하단에 bundle.js와 index.html이 생성되는지 확인하고 index.html에 &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 가 들어가 있는지 확인하자 webpack Dev Server간편한 개발을 위해 dev server 플러그인을 설정한다 1$ npm i webpack-dev-server --save-dev webpack.config.js 에 devServer 설정을, package.json엔 실행 스크립트를 추가한다 12345678910111213// webpack.config.jsconst path = require('path');const HtmlWebPackPlugin = require('html-webpack-plugin');module.exports = &#123; // .. 생략 devServer: &#123; port: 3000, contentBase: \"./dist\" &#125;, // .. 생략&#125; 123456789// package.json&#123; // ...생략 \"scripts\": &#123; \"start\": \"webpack-dev-server\", \"build\": \"webpack\" &#125; // ...생략&#125; npm run start로 서버를 실행하고, 브라우저에서 localhost:3000으로 접속하여 Hello App이 뜨는걸 확인 참고자료 react-webpack-babel kleopetrov blog webpack3 설정 react directory structure","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Front-End","slug":"Develop/Front-End","permalink":"http://choduk.github.io/categories/Develop/Front-End/"}],"tags":[{"name":"env","slug":"env","permalink":"http://choduk.github.io/tags/env/"},{"name":"react","slug":"react","permalink":"http://choduk.github.io/tags/react/"},{"name":"babel","slug":"babel","permalink":"http://choduk.github.io/tags/babel/"},{"name":"webpack","slug":"webpack","permalink":"http://choduk.github.io/tags/webpack/"}]},{"title":"SpringBoot에 Multi Data Source 적용하기","slug":"jpa/multi-data-source","date":"2017-07-03T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/07/04/jpa/multi-data-source/","link":"","permalink":"http://choduk.github.io/2017/07/04/jpa/multi-data-source/","excerpt":"","text":"DataSource 설정123456789101112// application.yml// DB를 나누기 위해, 메모리 디비를 두개 띄운다app.datasource.blue: url: jdbc:h2:mem:blue username: sa password: app.datasource.green: url: jdbc:h2:mem:green username: sa password: Package Tree DataSourceConfig123456789101112131415161718192021222324252627282930313233343536373839@Configuration@EnableJpaRepositories( basePackages = &#123;BLUE_ENTITY_BASE_PACKAGES&#125;, entityManagerFactoryRef = \"blueEntityManagerFactory\", transactionManagerRef = \"blueTransactionManager\")public class BlueDataBaseConfig &#123; public static final String BLUE_ENTITY_BASE_PACKAGES = \"com.example.demo.blue\"; // 예제엔 Entity와 Repository가 같은 패키지에 있으므로, 위에 패키지 하나로 공유한다 @Bean @Primary @ConfigurationProperties(\"app.datasource.blue\") public DataSourceProperties blueDataSourceProperties() &#123; return new DataSourceProperties(); &#125; @Bean @Primary public DataSource blueDataSource() &#123; return blueDataSourceProperties().initializeDataSourceBuilder().build(); &#125; @Bean @Primary public LocalContainerEntityManagerFactoryBean blueEntityManagerFactory(EntityManagerFactoryBuilder builder) &#123; return builder .dataSource(blueDataSource()) .packages(BLUE_ENTITY_BASE_PACKAGES) .persistenceUnit(\"blue\") .build(); &#125; @Bean @Primary public PlatformTransactionManager blueTransactionManager(@Qualifier(\"blueEntityManagerFactory\") EntityManagerFactory entityManagerFactory) &#123; return new JpaTransactionManager(entityManagerFactory); &#125;&#125; Blue, Green Config가 크게 다르지 않아서 생략.. 하단에 Github을 참고할것(Green에는 @Primary가 빠져있고, 이름만 green으로 시작함) 단일 DataSouce에서 JPA의 EntityManagerFactory, TransactionManager가 존재하므로 이를 나눠줘야 함 TransactionManager가 나뉘어졌으므로, @Transcation을 사용할때 주의할것 SpringBoot 1.3.X 버전부터 EntityManagerFactoryBuilder의 패키지가 변경되었다 (org.springframework.boot.autoconfigure.orm.jpa.EntityManagerFactoryBuilder -&gt; org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder) 주의사항 반드시 1개의 DataSource에 @Primary키워드를 붙여야 한다. 샘플 Github 예제코드 참고자료 Spring.io 공식문서","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Spring","slug":"Develop/Spring","permalink":"http://choduk.github.io/categories/Develop/Spring/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://choduk.github.io/tags/Spring-Boot/"},{"name":"Spring Data JPA","slug":"Spring-Data-JPA","permalink":"http://choduk.github.io/tags/Spring-Data-JPA/"}]},{"title":"SOLID - 의존관계 역전 원칙 (DIP)","slug":"solid/dip","date":"2017-06-15T15:00:00.000Z","updated":"2017-10-17T08:17:52.000Z","comments":true,"path":"2017/06/16/solid/dip/","link":"","permalink":"http://choduk.github.io/2017/06/16/solid/dip/","excerpt":"","text":"Dependency inversion principle 상위레벨 모듈이 하위레벨 모듈에 의존하면 안된다. 상위/하위 모듈 모두 추상화에 의존해야 한다. 추상화는 구현체를 의존하면 안된다. 중요한점 OO의 핵심이다. IoC를 통해 상위래밸의 모듈을 하위레벨 모듈로 부터 보호하는 것이다. 이를 통해 OCP를 지키고, 새로운 요구사항을 반영 가능 예제 let) 편의상 Object A =&gt; A, Object B =&gt; B, interface A =&gt; a 라고 하자…{: .center-image} Figure1 그림에서, A -&gt; B 방향으로 Compile time 의존성과 Run time 의존성을 갖고있다. Figure2 그림에서, A,B -&gt; a 방향으로 Compile time 의존성을 맺었지만, Run time 의존성은 그대로이다. 즉, 더이상 A는 B로 의존하지 않으며, A,B 둘다 Compile time에 a에 의존하게 된다. 이때, B의 Compile time의존성 방향이, A의 Run time 의존성 방향과 반대가 되게 된다.이와같이 소스 코드의 의존성 방향이 제어의 흐름과 반대 방향이 될 때, 의존성이 역전됐다고 한다. DIP는 Run time의존이 아닌 Compile time (source code)의존을 역전시킴으로써 변경의 유연함을 확보할 수 있도록 만들어주는 원칙이다. 위 예제에서 Package를 보면, DIP가 적용됨에 따라, interface를 Package A에서 가져가게 되었다. 즉, interface 타입을 가져감으로써 A와 B를 독립적으로 배포(jar, DLL 등)할 수 있도록 만들어 준다. 참고자료 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 클린코더스 강의(15.1강 DIP)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"SOLID - 인터페이스 분리 원칙 (ISP)","slug":"solid/isp","date":"2017-06-04T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/06/05/solid/isp/","link":"","permalink":"http://choduk.github.io/2017/06/05/solid/isp/","excerpt":"","text":"Interface segregation principle 클라이언트는 자신이 사용하는 메서드에만 의존해야 한다. 사용하지 않는 의존성을 갖고 있다면 인터페이스 변경시 재컴파일/빌드/배포가 필요하므로 독립적인 개발/배포 불가능 사용하는 기능만 제공하도록 인터페이스를 분리하여, 사이드이펙트 최소화 클라이언트 입장에서 인터페이스를 분리 흔하디 흔한 스타크래프트 예제12345678910111213141516171819202122232425262728interface Unit &#123; void move(); void attack();&#125;class Marine implements Unit &#123; @Override public void move() &#123; // ... 생략 &#125; @Override public void attack() &#123; // ... 생략 &#125;&#125;class Medic implements Unit &#123; @Override public void move() &#123; // ... 생략 &#125; @Override public void attack() &#123; // 메딕은 공격이 없는데?? &#125;&#125; 개선된 코드1234567891011121314151617181920212223interface Unit &#123;&#125;interface Movable &#123; void move();&#125;interface Attackable &#123; void attack();&#125;class Marine implements Unit, Movable, Attackable &#123; // ... 동일하므로 생략&#125;class Medic implements Unit, Movable &#123; @Override public void move() &#123; // ... 생략 &#125; // attack()에 대해 의존하지 않음&#125; 참고자료 클린코더스 강의(14.3강 ISP)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"SOLID - 리스코프 치환 원칙 (LSP)","slug":"solid/lsp","date":"2017-06-03T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/06/04/solid/lsp/","link":"","permalink":"http://choduk.github.io/2017/06/04/solid/lsp/","excerpt":"","text":"Liskov substitution principle 상위타입 객체를 사용하는 프로그램은 상위타입 대신 하위타입 객체를 사용해도 클라이언트의 수정 없이 정상적으로 동작해야 한다. LSP 위반 사례 명세에 벗어난 값 리턴 명세에 벗어난 익셉션 발생 명세에 벗어난 기능 수행 instanceof / downcasting을 사용한것은 전형적인 LSP 위반 LSP의 대표적인 예(직사각형-정사각형 문제)1234567891011121314151617181920212223242526272829303132333435class Rectangle &#123; private int width; private int height; public void setWidth(int width) &#123; this.width = width; &#125; public void setHeight(int height) &#123; this.height = height; &#125; public int getWidth() &#123; return width; &#125; public int getHeight() &#123; return height; &#125;&#125;// 직사각형을 상속받아 정사각형을 만들었을때class Square extends Rectangle &#123; @Override public void setWidth(int width) &#123; super.setWidth(widht); super.setHeight(widht); &#125; @Override public void setHeight(int height) &#123; super.setWidth(height); super.setHeight(height); &#125;&#125; 위 코드의 문제점 LSP를 위반하는 부분 12345void increaseHeight(Rectangle rec) &#123; if(rec.getHeight() &lt;= rec.getWidth()) &#123; rec.setHeight(rec.getWidth() + 10); &#125;&#125; 위와같은 코드를 작성하고 파라미터로 Square를 넘겼을때 width, height가 모두 증가하게 된다. 즉, height만 증가 시킬 수 없다 떄문에, if(rec instance of Square) 와 같은 코드를 넣어서 막아야 한다 이는 상위타입이 하위타입을 대체하지 못해서 코드의 수정이 이뤄졌으므로, LSP를 위반한다. 참고자료 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 클린코더스 강의(14.2강 LSP)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"SOLID - 개방 폐쇄 원칙 (OCP)","slug":"solid/ocp","date":"2017-06-02T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/06/03/solid/ocp/","link":"","permalink":"http://choduk.github.io/2017/06/03/solid/ocp/","excerpt":"","text":"Open-closed principle 확장에는 열려 있고 변경에는 닫혀 있어야 한다. (변화하는 부분을 추상화하여) 기능에 대한 변경/확장이 쉬워야한다. (확장 : 새로운 타입을 추가) 기능을 사용하는 코드는 고정된 추상(abstract, interface)에 의존하므로 소스코드의 수정이 이뤄지면 안된다. OCP를 위배하는 전형적인 특징 다운 캐스팅 123456789// 개발자가 반드시 정복해야 할 객체 지향과 디자인패턴(114page 예제)public void drawCharacter(Character charcater) &#123; if (character instanceof Missile) &#123; Missile missile = (Missile) charcter; missile.drawSpecific(); &#125; else &#123; character.draw(); &#125;&#125; 비슷한 종류의 if-else 블록이 존재 OCP의 현실적인 문제들 (이론적으로 OK, 비실용적) 문제점 main partition에는 if-else 존재 Crystal ball problem (마법의 수정구 문제) 확장을 위해 모든 인터페이스를 준비해놓는 것은 현실적으로 불가능(복잡해짐) 고객은 만져보기위해 자기가 원하는게 뭔지 모른다. 고객은 예측하지 못한 기능추가 변경을 요구 (Unknown Unknowns) 해결책 BDUF (Big Design Up Front) 요구사항을 예측하여 과도한 설계로 인해 발생하는 문제점 대부분 필요치 않은 추상화로 매우 크고 무겁고 복잡해짐 추상화는 유용하고 강력한 만큼 비용도 큼 Agile Design 변화에 대한 가장 좋은 예측은 경험하는 것 예측하고 추상화하기 전에, 고객이 변경을 요구할때 추상화를 한다. 주단위 정도로 간단한 뭔가를 Delivery, 변경을 요구하면 코드를 리팩토링 참고자료 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 클린코더스 강의(14.1강 OCP) 위키백과","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"SOLID - 단일 책임 원칙 (SRP)","slug":"solid/srp","date":"2017-05-28T15:00:00.000Z","updated":"2017-10-18T16:15:49.000Z","comments":true,"path":"2017/05/29/solid/srp/","link":"","permalink":"http://choduk.github.io/2017/05/29/solid/srp/","excerpt":"","text":"Single responsibility principle 클래스는 하나의 책임만 가지며 클래스는 그 책임을 완전히 캡슐화 해야 한다. 여러 책임을 갖고 있는 DataViewer 클래스1234567891011121314151617181920212223// 개발자가 반드시 정복해야 할 객체 지향과 디자인패턴(106page 예제)class DataViewer &#123; public void display() &#123; String data = loadHtml(); updateGui(data); &#125; public String loadHtml() &#123; HttpClient client = new HttpClient(); client.connect(url); return client.getResponse(); &#125; private void updateGui(String data) &#123; GuiData guiModel = parseDataToGuiData(data); tableUI.changeData(guiModel); &#125; private GuiData parseDataToGuiData(String data) &#123; // 파싱 처리 코드 &#125;&#125; 위 코드의 문제점 하나의 책임이 다른 책임까지 영향을 준다 (data를 가져오는 방식이 HTTP방식에서 다른 방식으로 변경된다면, 관련된 모든 코드가 수정되어야 한다.) data를 가져오는 새로운 방식이 추가됐다면, 사용하지 않더라도 불필요한 package를 포함되어야 한다. 개선방안 DataLoader, DataDisplayer 두가지 책임을 분리한다. 둘 간에 주고 받을 데이터를 String이 아닌 추상화된 타입으로 변경한다. 개선된 코드 112345678910111213141516171819202122232425262728293031class Data &#123; ...&#125;class DataLoader &#123; public Data load() &#123; ... &#125;&#125;class DataDisplayer &#123; public void display(Data data) &#123; ... &#125;&#125;class DataViewer &#123; private DataLoader loader = new DataLoader(); private DataDisplayer displayer = new DataDisplayer(); public void display() &#123; Data data = loader.load(); displayer.display(data); &#125; public String loadData() &#123; Data data = loader.load(); return dataToString(data); &#125;&#125; 남아있는 문제점 DataViewer가 DataLoader, DataDisplayer 두 클래스와 Composition을 관계를 형성하므로, 강한 coupling이 존재한다. DataLoader, DataDisplayer 두 클래스가 변경되면, DataViewer 클래스가 영향을 받는다. 개선방안 DataLoader, DataDisplayer를 Aggregation으로 변경한다. 즉, 외부에서 의존성 주입을 한다. (객체간 life cycle 다름) 개선된 코드 2123456789101112131415161718192021222324252627282930313233class Data &#123; ...&#125;interface DataLoader &#123; Data load();&#125;interface DataDisplayer &#123; void display(Data data);&#125;class DataViewer &#123; private final DataLoader loader; private final DataDisplayer displayer; // 외부에서 의존성 주입 public DataViewer(DataLoader loader, DataDisplayer displayer) &#123; this.loader = loader; this.displayer = displayer; &#125; public void display() &#123; Data data = loader.load(); displayer.display(data); &#125; public String loadData() &#123; Data data = loader.load(); return dataToString(data); &#125;&#125; 책임을 나누는 방법 많은 프로그래밍 경험을 바탕으로 감각적으로…(-_-;;) 매서드를 실행하는 주체(Actor)를 확인해 본다 1234567891011121314151617class GUIApplication &#123; ...&#125;class DataProcessor &#123; ...&#125;class DataViewer &#123; public void display() &#123; ... &#125; public String loadData() &#123; ... &#125;&#125; 위와 같은 상황이라면, GUIApplication 클래스는 DataViewer.display() 매서드를, DataProcessor클래스는 DataViewer.loadData() 매서드가 필요하므로, 두 매서드는 각각 다른 책임이므로 분리해야할 가능성이 높다. 참고자료 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴 클린코더스 강의(13강 SRP)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"SOLID","slug":"Develop/SOLID","permalink":"http://choduk.github.io/categories/Develop/SOLID/"}],"tags":[{"name":"SOLID","slug":"SOLID","permalink":"http://choduk.github.io/tags/SOLID/"}]},{"title":"Design Pattern - 행동패턴 (2)","slug":"design-pattern/behavioral-2","date":"2017-05-18T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/05/19/design-pattern/behavioral-2/","link":"","permalink":"http://choduk.github.io/2017/05/19/design-pattern/behavioral-2/","excerpt":"","text":"7.Observer 객체 사이에 1:N 의존관계를 맺고있으며, 한 객체의 상태가 변경되면 의존적인 다른 모든 객체들에게 통지하여 상태를 갱신할 수 있는 패턴 구조{: .center-image} 활용 두개의 추상화 개념이 있고 하나가 다른 하나에 대해 종속적일때, 각각을 별도의 객체로 캡슐화하여 재사용할 수 있음 한 객체에 변경으로 인해 다른 객체를 변경해야하는데, 이때 얼마나 많은 객체들이 변경되어야 할지 모를 때 한 객체가 자신이 변화를 통보하지만 이 변화에대해 관심있는 객체들이 누구인지 몰라도 될 때 결과 Subject와 Observer 간에 추상적인 결합도만 존재함 브로드캐스트(broadcase) 방식의 커뮤니케이션 가능 예측하지 못한 정보를 갱신할 수 있음 잘 알려진 사용 예 스프레드시트와 바 차트 8. State 객체의 내부 상태에 따라 스스로 행위를 변경하도록 하는 패턴 (마치 클래스가 바뀌는 것처럼 보인다) 구조{: .center-image} 활용 런타임에 객체의 행동이 상태에 따라 달라져야할 때 객체의 상태를 나열형 상수(enumerated constant)로 정의해야 할때, 이를 각각의 객체로 정의하여 다른 객체들과 상관없이 그 객체의 상태를 다양화 함 결과 if, switch-case 을 통해 상태별 행위를 처리하지 않고, 서로 다른 상태에 대해 별도의 객체로 표현하여 상태에 따른 행위를 국소화할 수 있음 상태 전이를 명확하게 만듬 (Context객체가 일관되지 않은 상태가 되는것을 막아 줌) 상태객체는 공유될 수 있음 (행동만 있는 Flyweight 처럼 보임) 잘 알려진 사용 예 TCP 프로토콜의 연결 포토샵과 같은 도구에서 선택도구를 이용한 방법 (그림관련 도구 활성화 -&gt; 그림 그려짐, 선택도구 활성화 -&gt; 그림 선택) 9. Strategy 동일 계열의 알고리즘을 정의하고 각 알고리즘을 캡슐화하여 이들을 상호교환 되도록 한다알고리즘을 사용하는 클라이언트와 상관없이 독립적으로 알고리즘을 다양하게 변경할 수 있게 한다 구조{: .center-image} 활용 Strategy패턴은 많은 행동 중 하나를 가진 클래스를 구성할 수 있는 방법을 제공 알고리즘의 변형이 필요할 때 사용자가 몰라야 하는 데이터를 사용하는 알고리즘이 있을 때 노출하지 말아야 할 복잡한 자료구조를 Strategy에 캡슐화 한다 하나의 클래스가 많은 행동을 정의하고, 그 클래스의 연산 안에서 복잡한 다중 조건문의 모습을 취하는 경우 많은 조건문보다는 각각의 Strategy클래스로 바꾸는것이 좋다. 결과 동일 계열의 관련 알고리즘군이 생김 서브클래싱을 사용하지 않는 대안 (context와 무관하게 알고리즘 변경 가능) 조건문을 없앨 수 있음 구현의 선택가능 클라이언트가 서로 다른 전략을 알고 있어야 함 Strategy객체와 Context객체 사이에 메시지 오버헤드가 있음 (모든ConcreteStrategy클래스는Strategy`인터페이스를 공유하기 때문에 사용되지 않는 파라미터를 초기화 경우도 있음) 객체 수 증가 10. Template Method 어떤 작업을 수행하는 알고리즘의 뼈대만 정의하고, 각 스탭별로 수행하는 구체적인 처리는 서브클래스에게 위임 구조{: .center-image} 활용 어떤 알고리즘에 변하는 부분과 변화지 않는 부분을 분리하여, 뼈대만 작성하고(변하지 않는 부분) 구현은(변하는 부분) 서브클래스에게 위임할 때 서브클래스간에 중복된 부분을 추출하여 공통 클래스에 몰아둠으로써 중복을 제거하고자 할때(refactoring to generalize의 좋은 예) 서브클래스 확장을 제어할 수 있음 (특정시점에 hook을 호출하도록 정의하여 그 시점에만 확장 가능하도록 할 수 있음) 결과 Hollywood principle(Don’t call us, we’ll call you)와 같은 역전된 제어 구조가 나타남 Template Method는 아래 operation 중 하나를 호출함 Concrete operation Abstract class Factory method hook operation 잘 알려진 사용 예 거의 모든 추상 클래스에서 사용할 정도로 다양하게 쓰임 11. Visitor 객체 구조를 이루는 원소에 대해 수행할 연산을 표현, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있음 구조{: .center-image} 활용 객체 구조가 다른 인터페이스를 가진 클래스를 포함하고 있어서 구체 클래스에 따라 오퍼레이션을 수행하고자 할때 각각 특징이 있고 관련되지 많은 오퍼레이션들이 어떤 객체에 대해 수행해야 하지만, 오퍼레이션때문에 객체가 복잡하게 되고 싶지 않을 때 객체 구조를 정의한 클래스는 변경되지 않지만, 전체 구조에 걸쳐 새로운 연산을 추가하고 싶을 때 구조를 변경하면 인터페이스 변경이 필요하므로 비용이 더 커질 수 있다. (이경우 해당 연산을 클래스에 정의하는 것이 나음) 결과 새로운 오퍼레이션 추가가 쉬움 Visitor를 통해 관련된 연산을 한 군데로 모아, 관련되지 않은 오퍼레이션을 뗴어낼 수 있음 새로운 ConcreteElement 클래스를 추가하기 어려움 클래스 계층 구조에 걸쳐서 방문함 상태를 누적할 수 있음 캡슐화를 위반할 수 있음 Visitor패턴 적용시 이슈 Double Dispatch : 실행되는 오퍼레이션이 요청의 종류와 수신자의 타입에 따라 달라짐 (방문자는 원소의 각 클래스에 대해 서로 다른 연산을 요청할 수 있음) 누가 객체 순회를 책임지는가? 잘 알려진 사용 예 Smalltalk-80 컴파일러 (소스코드 분석시에 사용)","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Design Pattern","slug":"Develop/Design-Pattern","permalink":"http://choduk.github.io/categories/Develop/Design-Pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://choduk.github.io/tags/design-pattern/"},{"name":"behaviroal","slug":"behaviroal","permalink":"http://choduk.github.io/tags/behaviroal/"}]},{"title":"Design Pattern - 행동패턴 (1)","slug":"design-pattern/behavioral-1","date":"2017-05-14T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/05/15/design-pattern/behavioral-1/","link":"","permalink":"http://choduk.github.io/2017/05/15/design-pattern/behavioral-1/","excerpt":"","text":"행동 패턴이란?책임 및 알고리즘을 어떤 객체에 할당하는 것이 좋은지 다룬 패턴 객체간의 교류방법에 대해 정의하여 런타임에 수행하기 어려운 복잡한 제어 구조를 패턴화 한 것 1. Chain of Responsibility 메시지를 보내고 처리하는 객체들 간의 커플링를 없애기 위한 패턴, 각 핸들러는 자신이 처리할 수 있으면 처리하고, 처리할 수 없으면 다음 핸들러에게 요청을 넘긴다. 구조{: .center-image} 활용 하나 이상의 객체가 요청을 처리해야하며 핸들러의 우선순위가 없으며, 각 객체가 자동으로 선택 되어야 할 때 리시버를 명시하지 않은 채 특정 객체에게 요청하고 싶을 때 요청을 처리할 수 있는 객체집합이 동적으로 정의되어야 할 때 결과 객체 간의 결합도(coupling)가 줄어듬 (다른 객체가 요청을 어떻게 처리하는지, 연결구조가 어떻게 된지 몰라도 된다) 책임을 할당하는데 유연성을 높일 수 있음 (책임을 여러 객체에게 분산 시킬 수 있으며, 런타임에 추가/변경/확장 이 가능함) 어떤 객체가 처리할지 명시하지 않으므로, 메시지 처리에 대한 보장이 되질 않음 잘 알려진 사용 예 클래스 라이브러리에서 이벤트 처리 (EventHandler) Logger 2. Command 하나의 요청을 하나의 객체로 캡슐화하여 파라미터처럼 사용할 수 있도록하며 요청을 되돌릴 수 있는 기능을 지원 구조{: .center-image} 활용 수행할 행위를 파라미터로 만들고자 할 때 (절차지향 프로그래밍의 Callback() 과 동일) Command객체는 요청과 다른 생명주기를 가지므로 서로 다른 시간에 요청을 결과 호출객체와 구현객체를 분리 Command는 일급객체 이므로 다른 객체와 같은 방식으로 조작되고 확장할 수 있음 여러 Command를 조합해서 다른 Command를 만들 수 있음 (Composite패턴을 이용하여 여러 명령어 구성 가능) 새로운 Command를 추가하기 쉬움 잘 알려진 사용 예 GUI에서의 메뉴에서 사용자가 MenuItem을 선택하면 Command에 등록된 Execute()연산을 호출함 3. Interpreter 어떤 언어에 대해, 문법에 대한 표현을 정의하면서 표현을 사용하여 해당 언어로 기술된 문장을 해석하는 해석자를 함께 정의 구조{: .center-image} 활용 정의할 언어의 문법이 간단함 효율성은 고려사항이 아님 가장 효율저인 interpreter를 구현하는 방법은 파스 트리를 직접 처리하는 것이 아니라, 일차적으로 파스트리를 다른 형태로 번역(translate) 시키는것 예를들어, 정규표현식은 일반적으로 유한상태기계(fninite state machine)으로 변역함 결과 문법을 확장하거나 바꾸기 쉽움 문법의 구현이 쉽움 복잡한 문법은 관리하기 어려움 새로운 표현식의 해석방법을 추가할 수 있음 잘 알려진 사용 예 객체지향 컴파일러 Composite패턴이 사용되는 곳에 Interpreter패턴을 사용할 수 있음, (단 Composite 패턴으로 정의한 클래스들이 하나의 언어 구조를 정의할 때만 Interpreter라고 불림) 4. Iterator 내부구조를 노출하지 않고, 집합 객체(aggregate object)에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공 구조{: .center-image} 활용 객체 내부 표현 방식을 모르고, 집합 객체의 각 원소들에 접근하고 싶을 때 집합 객체를 순회하는 다양한 방법을 지원하고 싶을 때 다른 집합 객체 구조에 대해서도 동일한 인터페이스를 제공하고자 할 때 결과 집합 객체의 다양한 순회방법을 제공 Iterator는 Aggregate클래스의 인터페이스를 단순하게 만듬 집합 객체에 따라 여러 순회 방법을 제공 잘 알려진 사용 예 컬렉션 클래스 5. Mediator 객체들간의 상호작용을 캡슐화하여 하나의 객체에 정의 (참조 관계를 직접 정의하기보다는 독립된 다른객체가 관리) 구조{: .center-image} 활용 여러 객체가 복잡한 상호작용을 가질 때 (객체간 의존성이 구조화 되어 있지 않고, 이해하기 어려울 때) 한 객체가 다른 객체를 너무 많이 참조하고 너무 많은 일을 수행하여 재사용하기 어려울 때 여러 클래스에 분산된 행동들이 상속없이 수정되어야 할 때 결과 서브클래싱 제한함 Colleague객체 사이의 종속성 줄임 객체 프로토콜을 단순하게 만듬 객체 간의 협력 방법을 추상화함 통제의 집중화 (Mediator 클래스 자체의 유지보수가 어려워질 수 있음) 잘 알려진 사용 예 Windows 플랫폼용 스몰토크/V의 응용프로그램에서 pane 클래스 계통의 객체들이 많이 제공되는데 (TextPane, ListBox, Button 등), 이들은 별다른 상속없이도 ViewManager 클래스만 상속받으면 된다. {: .center-image}{: .center-image} 스몰토크/V 에서의 Mediator 6. Memento 캡슐화를 위배하지 않을 채 어객체의 내부 상태를 캡처해두고, 이후 그 상태로 되돌아올 수 있도록 함 구조{: .center-image} 활용 객체 상태에 대한 스냅샷을 저장한 후 상태를 되돌릴 때 상태를 얻기위한 인터페이스를 두면 객체의 세부 구현이 드러나서 캡슐화가 위배될 때 결과 캡슐화된 경계를 유지할 수 있음 Originator 클래스가 단순해짐 Memento의 사용으로 더 많은 비용이 발생할 수 있음 제한적 / 광범위한 인터페이스를 정의해야함 (어떤 언어에서는 Originator 객체에서만 Memento의 상태 접근을 보장하기 어려울 수 있음) Caretaker는 자신이 보관한 Memento를 삭제할 책임이 있음으로, Memento를 관리하는데 추가적인 비용이 들어갈 수 있음","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Design Pattern","slug":"Develop/Design-Pattern","permalink":"http://choduk.github.io/categories/Develop/Design-Pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://choduk.github.io/tags/design-pattern/"},{"name":"behaviroal","slug":"behaviroal","permalink":"http://choduk.github.io/tags/behaviroal/"}]},{"title":"Design Pattern - 구조패턴","slug":"design-pattern/structural","date":"2017-05-13T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/05/14/design-pattern/structural/","link":"","permalink":"http://choduk.github.io/2017/05/14/design-pattern/structural/","excerpt":"","text":"구조 패턴이란?더 큰 구조를 형성하기 위해 어떻게 클래스와 객체를 합성하는지에 관련된 패턴 인터페이스나 구현을 복합하는 것이 아니라 새로운 기능을 실현하기 위해 객체를 합성하는 방법을 제공하여 런타임에 복합 방법이나 대상을 변경할 수 있음 1. Adapter 클래스의 인터페이스를 원하는 형태로 변환하여, 서로 다른 인터페이스를 갖는 클래스들을 함께 동작하게 하도록 함 구조{: .center-image} 활용 기존 클래스를 사용하고자 하는데 인터페이스가 맞지 않을 때 인터페이스가 맞지 않는 수정이 불가능한 라이브러리를 재사용하려 할 때 (객체 적응자(object adapter)만 해당) 수정해야할 인터페이스가 현실적으로 불가능할 정도로 많을 때 객체 적응자를 써서 부모 클래스의 인터페이스를 변형 결과 클래스 적응자(class Adapter) Adapter는 명시적으로 Adaptee를 상속받고 있을뿐 Adaptee의 서브클래스들을 상속받는 것이 아니므로 서브클래스들에 정의된 기능을 사용할 수 없음 객체 적응자(object Adapter) Adapter는 하나만 존재해도 여러 Adaptee와 동작 가능 Adpatee는 행위 재정의가 어려움 잘 알려진 사용 예 그래픽 객체에서 Graphic과 Line, Circle, Polygon, Spline 2. Bridge 추상과 구현을 분리하여, 독립적인 다양성을 가질 수 있도록 함 구조{: .center-image} 활용 추상과 구현 사이의 종속성을 제거하여 런타임에 구현 방법을 선택하거나 변경하고 싶을 때 추상과 구현 모두 독립적으로 확장이 필요 할 때 구현 내용을 변경한다고해서 추상이 다시 컴파일 될 필요 없어야 한다 클라이언트로부터 구현을 은닉하고 싶을 때 여러 객체들에 걸쳐 구현을 공유하며 이를 다른곳에 공개하지 않고 싶을 때 결과 인터페이스와 구현의 분리 (컴파일 타임 의존성 제거) 확장성 제고 (abstraction과 implementor를 독립적 확장) 구현 세부 사항 은닉 잘 알려진 사용 예 Set은 집합에 대한 추상을 정의, LinkedSet과 HashSSet은 개념적 연결 리스트나 해시테이블에 대한 구현을 제공 3. Composite 부분과 전체의 계층을 표현하기 위해 객체들을 모아 트리 구조로 구성하여 개별 객체와 복합객체를 모두 동일하게 다룰 수 있도록 함 구조{: .center-image} 활용 부분, 전체의 객체 계통을 표현하고 싶을 때 객체의 합성으로 생긴 복합객체와 단일객체의 사용을 동일하게 하고 싶을 때 결과 단일객체와 복합객체로 구성된 하나의 계통으로 정의하여 일관된 방식으로 애플리케이션 구성 가능 일관된 방식으로 구성가능하기 때문에 코드가 단순해짐 새로운 구성요소를 쉽게 추가 가능 지나치게 범용성을 갖게 되므로 구성요소에 대한 제약사항을 가하기 어려움 잘 알려진 사용 예 Smaltalk에서 MVC의 View가 Composite 이면서 뷰집합을 포함, 즉 Component이다 금융 분야에서 포트폴리오(portfolio)가 자산(asset)을 형성할 때, 포트폴리오는 각각 자신의 인터페이스를 만족하 전체를 하나의 집합으로 관리할 수 있는 Composite로 구현 4. Decorator 동적으로 새로운 책임을 추가하여, 서브클래스를 만드는것 보다 유연한 확장성 제공 구조{: .center-image} 활용 다른 객체에 영향을 주지 않고 새로운 책임을 추가 가능 책임이 제거될 수 있을때 사용 모든 조합을 지원하기위해 상속해야할 클래스가 지나치게 많을 때 결과 상속보다 유연한 설계로 확장성 제공 많은 기능이 상위 클래스에 누적되는 상황을 피할 수 있음 Decorator와 해당 ConcreteComponent가 동일하지 않음. Decorator는 일관된 인터페이스를 제공하는 껍데기 객체의 행동 뿐만 아니라 내부도 변경 가능 (대표적인예 : Strategy Pattern) 잘 알려진 사용 예 GUI 툴킷에서 위젯의 기능을 추가하고자 할 때 Stream Class (기본적인 I/O) 5. Facade 한 서브시스템을 합성한 여러 인터페이스의 집합에 대해 단순한 하나의 인터페이스를 제공 구조{: .center-image} 활용 복잡한 서브시스템에 단순한 인터페이스를 제공할 때 클라이언트와 서브시스템 간에 너무 많은 종속성이 존재할때, Facade를 통해 결합도를 줄이고 싶을 때 서브 시스템을 계층화하여 결과 서브시스템의 구성요소 보호 클라이언트와 서브시스템 간의 결합도 약화 Facade는 서브시스템을 완전히 막지 않기 때문에, 클라이언트가 Facade와 서브시스템을 선택할 수 있음 잘 알려진 사용 예 choices OS에서 다양한 H/W 플랫폼을 지원하기위해 FileSystemInterface와 주소 공간에 해당하는 Domain을 Facade로 정의 6. Flyweight 데이터를 서로 공유하여 사용하도록 하여 메모리 사용량을 최소화 구조{: .center-image} 활용 애플리케이션이 대량의 객체를 사용할 때 객체의 수가 너무 많아져서 저장 비용이 너무 높을 때 대부분의 객체 상태를 부가적인 것으로 만들 수 있을 때 부가적인 속성을 제외하면 비교적 적은 수의 공유된 객체로 대체될 수 있을 때 애플리케이션이 객체에 식별자의 의존하지 않을 때 결과 공유해야하는 인스턴스의 전체 수를 줄일 수 있음 객체별 상태의 양을 줄일 수 있음 부가적인 상태는 연산되거나 저장할 수 있음 잘 알려진 사용 예 Doc문서 편집기에서 하나의 glyph인스턴스를 만들어 특정 스타일의 문자로 공유할 수 있음 (본질적 상태는 글자의 코드와 스타일정보 부가적인 정보는 글자의 위치) 그 결과 18만 글자를 저장하기 위해 단지 480개의 문자 객체만 저장하면 되었음 ET++에서 룩앤필 독립성 보장 스크롤바, 버튼 메뉴 등 위젯이라고 알려진 사용자 인터페이스 요소(layout)와, 음영 각도 등의 장식으로 분리 7. Proxy 객체에 대한 접근을 제어하기 위해서 그 객체를 담을 수 있는 그릇을 제공하는 것입니다 구조{: .center-image} 활용 remote proxy : 서로 다른 주소 공간에 존재하는 객체를 가르키는 객체 virtual proxy : 요청이 있을 때만 필요한 고비용 객체를 생성 protection proxy : 원래 객체에 대한 실제 접근을 제어 smart reference : 실제 객체에 접근이 일어날 때 추가적인 행동을 수행 실제 객체에 대한 참조 횟수를 저장하다가 더는 참조가 없을 때 객체를 제거 (smart pointer 라고 불림) 맨 처음 참조되는 시점에 영속성 저장소의 객체를 메모리로 옮김 실제 객체에 접근하기 전에, 다른 객체가 그것을 변경하지 못하도록 실제 객체에 대한 잠금 결과프록시 패턴은 어떤 객체에 접근할 때 추가적인 작업을 할 수 있는 통로를 제공 remote proxy는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있음 virtual proxy는 요구에 따라 객체를 생성하는 등의 처리를 최적화 할 수 있음 protection proxy / smart reference는 객체가 접근할 때 마다 생성 및 삭제 등의 추가 관리를 책임짐","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Design Pattern","slug":"Develop/Design-Pattern","permalink":"http://choduk.github.io/categories/Develop/Design-Pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://choduk.github.io/tags/design-pattern/"},{"name":"structural","slug":"structural","permalink":"http://choduk.github.io/tags/structural/"}]},{"title":"Design Pattern - 생성패턴","slug":"design-pattern/creational","date":"2017-05-08T15:00:00.000Z","updated":"2017-10-17T08:11:59.000Z","comments":true,"path":"2017/05/09/design-pattern/creational/","link":"","permalink":"http://choduk.github.io/2017/05/09/design-pattern/creational/","excerpt":"","text":"생성 패턴이란?인스턴스의 생성/합성 방법을 추상화하여 시스템이 어떤 서브클래스를 사용하지에 대한 정보를 캡슐화 누가, 언제, 무엇을, 어떻게 생성할 것인지 결정하는 데 유연성을 확보할 수 있다 1. Factory Method 객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 인스턴스를 생성할지에 대한 결정은 서브클래스에게 위임 구조 활용 생성할 객체 타입을 예측할 수 없을 때 생성할 객체를 기술해야하는 책임을 서브클래스에게 위임하고자 할 때 객체 생성의 책임을 서브클래스(ConcreteProduct)에 위임하고, 서브클래스에 대한 정보를 은닉할 필요가 있을 때 결과 컴파일 타임에는 인터페이스/추상클래스에(Product) 의존성을 맺지만, 런타임에는 서브클래스에(ConcreteProduct) 의존성을 갖게되므로 느슨한 결합(loose coupling)을 할 수 있음 느슨한 결합을 통해, 새로운 서브클래스(ConcreteProduct)를 쉽게 추가할 수 있음 서브클래스(ConcreteProduct)에 대한 hook 메소드 제공 (객체 생성 전후로 어떤 행위를 추가하기 쉬움) 병렬적인 클래스 계통을 연결하는 역할을 담당 (자신의 책임을 다른 클래스에 위임하는것) 2. Abstract Factory 독립적인 여러 제품군(AbstractProduct)을 생성할 수 있는 인터페이스(AbstractFactory)를 제공 구조 활용 서브 클래스의 생성/구성/표현 방식에 의존하지 않는 프로그램 작성할때 특정 Product 하나를 애플리케이션 설정과 함께 다른 Product으로 대체할 때 어떤 Product의 제약사항을 외부에서도 따르게 하고자 할때 Product에 대한 클래스 라이브러리를 제공하고, 구현이 아닌 인터페이스만 노출하고자 할 때 결과 Product의 생성/구성/표현 방식에 대한 전반적인 과정을 캡슐화하여 서브 클래스에 위임했기 때문에, 구체적인 클래스를 분리되어 있음 애플리케이션내에 팩토리의 서브클래스(ConcreteFactory)를 변경하기 쉬기 때문에, 제품군(AbstracProduct)을 쉽게 대체 가능 오직 팩토리의 서브클래스(ConcreteFactory)에서만 객체를 생성함으로, 애플리케이션내에 Product 객체들의 일관성을 높일 수 있음 새로운 Product를 제공하기 어려움 (AbstractFactory가 영향받으면 하위 모든 서브클래스가 영향을 받게됨) 3. Prototype 인스턴스를 복사해서 새로운 인스턴스를 만드는 것 구조 활용 인스턴스화 할 클래스를 런타임에 지정하고 싶을 때 팩토리에서와 같이 Product와 Factory를 병렬적으로 만들고 싶지 않을 때 클래스의 인스턴스가 구성/표현 방식이 복잡할 때 프레임워크와 인스턴스를 분리하고 싶을 때 Composite, Decorator 패턴이 많이 사용될 때 결과 런타임에 새로운 Product를 추가/삭제 할 수 있음 새로운 클래스의 생성 없이 객체에 정의된 필드에 따라 행위를 변경 가능 구조를 다양화 하여 새로운 객체 정의 가능 서브클래스의 수를 줄일 수 있음 동적으로 클래스에 따라 애플리케이션 구성 가능 4. Singleton 오직 한개의 클래스 인스턴스만 갖도록 보장하고, 전역적인 접근을 제공 구조 활용 클래스의 인스턴스가 오직 하나이면서, 전역적인 접근이 필요 할 때 유일한 인스턴스가 서브클래싱으로 확장되어야 하며, 사용자는 코드의 수정 없이 확장된 서브클래스의 인스턴스를 사용할 수 있어야 할 때 결과 유일하게 존재하는 인스턴스로 전역적 접근 통제 namespace의 제한 연산 및 표현의 정제 허용 인스턴스의 개수를 변경하기가 자유로움 클래스 연산을 사용하는 것보다 훨씬 유연 클래스로더가 여러개 있다면, 클래스 로더를 직접 지정해서 사용할 것(여러개의 인스턴스 생성 가능) 고전적인 방식의 lazy instantiation 생성시 멀티스레드 상황에서 문제가 생길 수 있으니 주의할것 해결법은 다음과 같다. 속도의 문제가 없다면 synchronized 사용 DCL(Double-checking locking)을 사용하여 getInstance()의 동기화 부분을 줄임 12345678910private Singleton instance;public static Singleton getInstance()&#123; if (instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null) instance = new Singleton(); &#125; return instance; &#125; 인스턴스를 처음부터 생성 (권장사항) 1private static Singleton instance = new Singleton(); 특별한 문제가 없다면 Singleton으로 만들어진 객체는 반드시 추가적인 인스턴스 생성을 못하게 막아야 함 5. Builder 복잡한 객체를 생성 및 표현방법을 분리하여, 서로 다른 표현이라도 객체를 생성할 수 있는 동일한 방식을 제공 구조 활용 복합객체 생성 방법이, 각 요소들의 조합 방법에 독립적일 때 합성할 객체들의 표현방법이 다르더라도, 생성과정에서 이를 지원해야 할 때 결과 객체 내부 표현을 다양하게 변화 가능 생성과 표현의 코드를 분리 복합 객체 생성 절차를 세밀하게 분류 가능","categories":[{"name":"Develop","slug":"Develop","permalink":"http://choduk.github.io/categories/Develop/"},{"name":"Design Pattern","slug":"Develop/Design-Pattern","permalink":"http://choduk.github.io/categories/Develop/Design-Pattern/"}],"tags":[{"name":"design pattern","slug":"design-pattern","permalink":"http://choduk.github.io/tags/design-pattern/"},{"name":"creational","slug":"creational","permalink":"http://choduk.github.io/tags/creational/"}]}]}